### 大数据分析与内存计算大作业

#### 实现思路
- 内存数据库
  - 在内存中使用 `DashMap`（基于分片的高性能并发哈希表，在 `shard` 的粒度上维持锁，从而实现高吞吐量） 维护一个 `hash` 索引结构，从而提供基本的 `PUT`、`GET`、`DELETE` 接口，并且能够支持并发操作。
- 持久化
  - 先通过 `WAL` 将请求持久化到日志文件中，再进行处理。
  - 定期将 `DashMap` 中维护的键值对持久化到文件中。

- 事务
  - `DashMap` 提供了获取指定的 `key` 对应 `value` 不可变引用 `get()` 与可变引用 `get_mut()` 的接口，对应着访问读/写锁。
  - 在 `begin` 时，获取事务中的操作需要访问的对象的可变应用或不可变引用，完成对应的操作之后，不释放对应的引用，而是将其所有权转移到在 `Transaction` 中，通过所有权的转移完成两阶段锁中增长阶段的持有锁的操作。
  - 在 `commit` 时，释放掉对应的 `Transaction`，这个操作会释放掉 `begin` 操作中获取的引用的所有权，完成两阶段锁的收缩阶段。
  - `abort` 时，由于 `begin` 时进行就地更新，因此，需要根据 `Transaction` 中记录的 `Log` 完成情况进行回滚，同时释放掉之前获取的引用。

#### 测试用例结果
- 增删改查
  - 通过测试用例 1，支持基本增删改查。
  ![](crud.jpg)

- 数据持久化到磁盘

  - 通过测试用例 2，在关闭数据库之后，重启时，根据持久化文件恢复索引结构。
  ![](persist.jpg)
- 并发
  - 通过测试用例 3，开启三个线程，同时对数据库进行操作。
- ACID
  - 通过测试用例 4，开启三个线程，同时执行事务，保证了事务之间的隔离性，过程中始终维持着 `a = b` 这个不变性。
  ![](transaction_1.jpg)
  - 开启2个线程执行读写事务，8个线程执行只读事务（所有线程均执行 `60s`），保证了事务之间的隔离性，过程中始终维持着 `a <= b`，在完成读写事务时之后，满足 `a + 1 = b`。
  ![](transaction_2_1.jpg)
  - 开启2个线程执行读写事务（执行 `60s`），8个线程执行只读事务（执行 `20s`），吞吐量明显上升。
  ![](transaction_2_2.jpg)
  - 分析：rust 语言以及 DashMap 中可变引用接口 get_mut() 与不可变引用接口 get() 的安全机制判断相同，允许同时存在多个不可变引用，不允许可变引用与不可变引用同时存在，也不允许同时存在多个可变引用；对于测试用例 5，同时存在多个线程执行只读事务，即使当前的只读事务在执行，已经获取到查询对象的不可变引用，但另一个只读事务仍然可以继续获取查询对象的不可变引用，因此只读事务会一直保持查询对象的不可变引用，继而导致读写事务持续被阻塞。

#### 存在的问题
- 对于持久化的文件，没有采用优化过的数据结构进行保存，而是直接将 key-value 保存在文件中，对于性能影响较大；