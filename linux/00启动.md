# Linux 入口

## head.S

内核启动入口在 `linux/arch/arm64/kernel/head.S` 。

要求: 关闭 MMU、D-cache 和 I-cache，且 x0 寄存器表示 FDT 的物理地址。

1. 在 `primary_entry` 中先调用 `record_mmu_state` 函数，先禁用 MMU，再调用 `preserve_boot_args` 函数保存启动的参数到 boot_args 数组中并使缓存无效。
2. 初始化 sp，清除缓存，调用 `init_kernel_el` 函数设置 CPU 的 Exception Level。
3. 执行 `_cpu_setup` 函数初始化处理器，主要是 MMU 相关的操作。
4. 跳转至 `_primary_switch` 函数，调用 `_enable_mmu` 打开 MMU，重新映射内核地址。
5. 跳转至 `_primary_switched` 函数，初始化 `init_task`，以及 percpu 的相关信息，初始化 vbar_el1 寄存器。
6. 调用 `set_cpu_boot_mode_flag` 函数保存启动的模式。
7. 调用 `finalise_el2` 函数。
8. 跳转至 `start_kernel` 函数。

其他核的启动流程为:

1. 在 `secondary_entry` 中调用 `init_kernel_el` 函数设置 CPU 的 Exception Level，跳转至 `secondary_startup`。
2. 调用 `_cpu_setup` 初始化处理器，主要是 MMU 相关的操作。
3. 调用 `_enable_mmu` 打开 MMU，跳转至 `_secondary_switched` 函数。
4. 调用 `finalise_el2` 函数。
5. 初始化 vbar_el1 寄存器。
6. 加载 `secondary_data`，并在 `boot_stack` 上初始化 `init_task`（每个 CPU 上的 `init_task` 不同）。
7. 跳转至 `secondary_start_kernel` 函数。

## start_kernel

文件的目录在 init/main.c 中。

1. 调用 `set_task_stack_end_magic` 函数，将栈的底部末端设置为 `STACK_END_MAGIC`。
2. 调用 `smp_setup_processor_id` 函数，设置好物理的 CPU ID 和逻辑的 CPU ID 的关系。
3. 调用 `debug_objects_early_init` 函数。
4. 调用 `init_vmlinux_build_id` 函数。
5. 调用 `cgroup_init_early` 函数，初始化默认层级、注册早期子系统、建立全局数据结构，为后续资源控制（如 CPU 配额、内存限制）和用户空间交互（通过 sysfs）提供底层支持（源自腾讯元宝）。
6. 关闭中断，调用 `boot_cpu_init` 函数。

