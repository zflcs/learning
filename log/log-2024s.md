### 用于记录日常

##### 20240307

- 花了半天的时间做了一个微信小程序来记录个人以及好友的读书详情
- 测试硬件逻辑
  - 在 verilator 中测试正常
  - 上板子测试，LUT: 53% -> 82%，优先级队列的基本功能仍然正常，但是外设的阻塞队列出队顺序不对， 按照这种情况，估计是由于资源占用过多导致的，并且外设里阻塞的协程是较高级的抽象，因此这个顺序没有影响
  - 把阻塞队列从 256 换成 128，LUT：82% -> 63%，原来不是出了问题，在 verilator 里的仿真结果也是顺序反过来了
  - 因为把队列的 position 固定死了为 0，所以它变成了栈，因此顺序反过来了，将队列从 DataArray 改成 PriorityQueue 后，顺序是正确的了，但 LUT 又回到了 81%，把 DataArray 的 length 接口暴露出来，用于g指定作为队列时的入队位置
- 尝试改 arceos 的驱动代码

##### 20240306

- 调试
  - 打开生成的 verilog 文件，看不到中断处理模块的入队和出队数据信号线
  - 主要的问题在与和优先级队列的连接方式，导致没有生成出队入队信号线
  - 将出队的接口连接到 MMIO 寄存器上，生成了对应的信号线，但是这个接口不需要连接到 MMIO 寄存器上，在写优先级队列时也存在同样的问题，应该是被 firrtl 优化了
- 写带有中断处理的优先级队列
  - 能够正常唤醒中断处理协程了
  - 但是不同的阻塞队列协程在入队时的顺序不对，查看波形，发现在注册中断处理协程时，入队下一个周期就马上入队了，因此顺序不正确
  - 接口对应的 interrupt 线在 verilog 中找不到，并且将阻塞队列的 deq.valid 直接连接到了 enq.ready，因此入队后会马上出队
  - 似乎是因为 chisel 提供的 queue 实现的原因，不管有没有使能，出队的 bits 总会指向队首的数据
  - 不考虑从设备的中断线传输到中断控制器这部分周期，中断控制器里的中断处理为 4 个时钟周期

##### 20240305

- 组会
- 将外部中断连接到中断控制器中
  - 在 LazyModule 类中添加 intnode（IntNexusNode）节点，在外层的 CanHavePeripheryATSINTC trait 中将这个 intnode 连接到 ibus.toPLIC
- 定义了 InterruptHandler 类，其中集成了队列，针对每个中断线，产生一个对应的中断处理模块
  - 提供一个 enq 接口，用于软件注册中断处理例程
  - 提供一个 deq 接口，连接到优先级队列的 enq0 接口，假定都为优先级最高，当外部中断信号被拉高时，将会产生一个信号，从内部集成的队列中取出中断处理例程，然后通过 deq 接口将其加入到优先级队列中
  - 入队正常工作
  - 出队还需要通过连接外设进行测试才可以
- 尝试直接在 rocket-chip 中直接找一个 gpio，将其连接到外部中断信号线上，直接在 verilator 中进行测试，而不用在真板子上测试（太耗时间）
  - 想复杂了，可以直接写 MMIO 寄存器，来模拟产生一个中断信号，验证基本的功能
  - 写完 MMIO 寄存器后，不能从优先级队列中取出中断处理例程，应该是入队的部分还存在问题，从波形中也看不到任何入队的操作

##### 20240304

- 突然想起昨天上板子测试，没有执行 make build 更换项目的 rocketchip-axu15eg.v，检查发现确实没有相关的优先级队列的代码
  - LUT: 33% -> 53%
  - 能够通过测试
- 写学期计划
- 完善设计文档
  - 画行为图
  - 补充接口的描述，在何时使用
- 测试硬件优先级队列出队、入队需要的 cycle，均在 40 个 cycle

##### 20240303

- 在 index block 中增加索引递增递减的功能，但是 position 计算错误，之前的写法有问题
- 基本的功能正常了，但是最后一个优先级的入队还存在问题，因为多了一个 eof 的索引，但是在计算时溢出了，导致计算的位置取到了优先级为 0 的索引
- 硬件优先级队列全部实现，并且连接到 rocket-chip 中，经过 verilator 验证，逻辑正常
- 合并 LX 的 pr
- 在 FPGA 上测试硬件优先级队列，与在 verilator 上的行为不符合，还需要用 ila 抓一下信号线才行
  - LUT 使用率为 33%

##### 20240302

- 写 index block，能够正常工作，将 index block 与 data array 连接在一起，正常工作

##### 20240301

- 硬件队列 debug，chisel 转化成 verilog 时，将 ready 和 valid 直接用组合逻辑连接在一起，导致了 `Combinational loop detected` 错误。
- 在单元测试时，能够正常工作，接入到 rocket-chip 时出现错误，查看波形，发现两边的 ReadyValid 接口部分信号线没有显示，mem 入队不正常，但 mem 出队的功能正常
- debug 硬件队列，出对和入队正常，能够在任意位置入队

##### 20240229

- 写 chisel 硬件代码实现，实现了一个高级的队列，能够在任意位置插入元素，从队头取出元素
- 修改简历
- 将自己实现的队列放到 rocket-chip 中出现错误：`Exception in thread "main" firrtl.transforms.CheckCombLoops$CombLoopException: : [module ExampleRocketSystem] Combinational loop detected`，可能是因为自己的队列中有些信号使用组合逻辑实现的

##### 20240228

- 开会讨论
- 阅读论文 EFFICIENT PRIORITY-QUEUE DATA STRUCTURE FOR HARDWARE IMPLEMENTATION
- 阅读代码 https://github.com/joonho3020/chisel-priorityqueue，代码并不是按照论文中描述的那样实现的，还是 用移位寄存器的方式，将输入信号广播到所有的数据块。
- 根据论文写优先级队列实现

##### 20240227

- 学习 SyetemVerilog，尝试把已有的优先级队列代码转换成 chisel 代码
- 找到了已有的 chisel 优先级队列实现，所以跳过学习 SystemVerilog
  - https://github.com/joonho3020/chisel-priorityqueue，根据 [Efficient Priority-Queue Data Structure for Hardware Implementation](https://ieeexplore.ieee.org/document/4380693) 实现的
  - [Chisel-based Implementation of High-performance Pipelined Priority Queue Generator](https://ieeexplore.ieee.org/document/9730477) 是 2022 年发表的
- 阅读论文 Chisel-based Implementation of High-performance Pipelined Priority Queue Generator
- 讨论设计方案
  - 阻塞队列抽象级别，针对网卡，出队入队、以及其他的原因导致的阻塞，如何使用一个比较抽象的接口来处理
  - 收发双方进行通信，处理流程

##### 20240226

- 组会
- 调试硬件
  - chisel 的 regfield 中的读采用 ReadyValidIO，而写采用 DecoupledIO，但这个不存在影响，DecoupledIO 是 ReadyValidIO 的子类
  - 目前的问题，无论是 queue 还是普通的寄存器，在 for 循环中连续的写，从 printf 和波形的结果来看，bits 只拉起了最后一次的数据
  - 在 for 循环中增加了无关的 printf 语句后，相当于增加了一点时间缓冲，输入的波形正常，每次写的 ReadyValidIO 接口的波形是正常的，输出的波形还不太正常，在 enq 的下一个周期，deq 马上会输出
  - 使用 queue 和寄存器都能够正常工作
- 同步小论文反馈意见
- 写硬件行为描述文档，画图
- 练字