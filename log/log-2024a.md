# 用于记录日常

## 20241125

- [x] 增加系统调用
  - 初始化，在用户态成功使用了 taic 的调度器功能
  - 增加系统调用异步唤醒机制
  - 整理代码逻辑

## 20241124

- [x] 调试 vDSO 模块
- [x] 在软件中增加与控制器相关的逻辑
  - 增加相关的系统调用

## 20241123

- [x] 学习 tokio
- [x] 学习 thread_local
- [x] 将 vDSO 整合成单独的模块

## 20241122

- [x] 注册会议
- [x] 作报告
- [x] 阅读 tokio 代码

## 20241121

- [x] debug
  - 任务状态修改以及就绪队列的操作，exit 与 wait_pid 之间的顺序，页表被释放导致出现页错误
- [x] 增加 qemu 控制器的代码逻辑
  - 修改 qemu 控制器的驱动，简化驱动代码
  - 编译用户态 so 共享库，在 build.rs 中指定 dylib 时，不能使用带有前缀 lib 和后缀 .so，否则报错找不到库
  - 成功使用编译的动态库中的接口

## 20241120

- [x] 修复 wakeup_task bug，支持多核运行
- [x] 接入硬件调度器
- [x] 组会
- [x] 写任务状态转移的文档
- [x] 检查 LX 的 pr

## 20241119

- [x] debug
  - 修改成全局队列之后，wakeup 存在问题，被多次唤醒，在多个核上执行，wakeup 需要与任务的状态进行绑定

## 20241117

- [x] 修改专利
- [x] 写代码
  - 修改内核的调度，修改 process 的调度器用于用户态协程和线程的调度，每个进程内核的任务由内核的调度器进行调度
  - 修改内核的调度之后，出现了 bug，根据日志打印，似乎是同一个任务在多个核上执行

## 20241116

- [x] 做 ppt

## 20241115

- [x] 整理共享调度器小论文

## 20241114

- [x] debug：异步系统调用内核实现，已经可以并行，首先需要将系统调用的返回值直接写到用户态的地址空间中，第二需要通知机制
  - 将返回值的指针作为参数传递给内核后，内核执行完后直接将结果写回到参数的指定位置
  - 将 waker 直接传递给内核，内核获取的用户态的 wake 函数和数据均是正确的，直接执行会出现内核指令页错误，因为不允许 S 模式执行 U 态代码，通过 mprotect 取消掉 U 标记位后，能够正常执行
  - 但这种方式会产生影响，对于那些正常执行完成的协程，这种方式会重复唤醒任务

## 20241113

- [x] 内核系统调用的改造
  - 阻塞和非阻塞的系统调用存在冲突，使用参数进行区分
  - 多核存在问题，两个核同时在处理系统调用，原因在于第一次读阻塞时，通过 yield_now 将其放回到了调度器内，这时其他核能够获取到这个信息，对于多核情况下，这个协程里保存的系统调用参数没有和之前保存的系统调用参数进行同步；首先需要解决参数一致的问题；其次需要解决多核之间用户态执行流与内核执行流之间的互斥
  - 创建新的内核任务，保证了参数一致，但接下来需要保证互斥，但参数似乎
- [x] 组会
- [x] debug：对于异步系统调用，新建内核协程来执行处理，但其中使用 await 时需要注意很多细节，容易导致 bug，不同的 waker 很容易导致 bug

## 20241112

- [x] 用户态异步系统调用接口
- [x] debug，内核页错误处理失败后，发送信号给线程，信号处理完成之后又进入到了内核的页错误处理流程中，导致循环
- [x] 内核异步系统调用实现
  - 进入内核，读阻塞后，下一次执行写系统调用时，仍然从写开始执行，没有重新开始，这里需要额外的机制

## 20241111

- [x] 构建用户态程序开发环境

## 20241110

- [x] 修改专利
- [ ] 写异步系统调用

## 20241109

- [x] 修改 taic 论文

## 20241108

- [x] debug
  - fatfs 多核情况下出现错误（原本 starry 也存在这个问题）
  - 出现了重复获取 Mutex 的情况，可能的原因是在 wake() 之前没有释放掉锁，修改之后没有出现
  - tkill 系统调用存在问题，导致 pthread_cancel_points 卡住：原因在于 clone_task 时没有设置 tls，导致用户程序异常
  - 目前的调度方式，fifo 调度器下能够正常工作，但 cfs 调度会导致问题，还不清楚问题的原因，修改了 wakeup 的实现之后能够正常工作，libc 的测试 cfs 调度器还是存在问题
  - 在 yield 和 sleep 时，不能够关中断，否则会导致一些需要时钟中断唤醒的任务无法被唤醒

## 20241107

- [x] debug
  - 使用 busybox 测试时，在退出任务时，发送信号给任务，但找不到所属的进程，原因在与进程内的调度任务所属的进程关系不正确，该调度任务为所属的父进程，并且需要增加相应的信号处理和 robust
  - smp bug：fatfs 存在 bug，两个核读写同一个文件时出现了错误
    - Mutex 存在 bug，可能第一次进行比较时还没有释放掉，但在需要 wait 时已经进入到了被释放掉了，因此可以直接获取任务
    - 创建任务时，由于任务在核间移动，导致出现了页错误，例如 init_user 创建第一个用户进程 e0 时，在 0 号核上直接写了 e0 的页表，但实际的任务还是内核的任务 kt1，kt1 页表没有 e0 用户地址空间的映射。因此当 kt1 迁移到 1 号核上时，即使刷新了页表，但这个页表还是内核的页表，因此没有用户态的地址映射。因此，需要区分，在什么时候，可以进行迁移。
    - 在用户态由于中断被抢占时，需要设置 TrapStatus 的状态为 unknown
  - 用户态异步系统调用库

## 20241106

- [x] 写代码
  - 文件系统与原有的实现差距太大，定位到 read_to_end 的实现，原本的实现会一次性将所有的数据读取到缓冲区中，修改之后每次只读 32 字节数据，修改之后有明显提升
  - 增加 devfs、ramfs
- [x] 组会
- [x] 写代码
  - 将 ramfs 的测试中的 bug 解决（使用 as_any 时调用了默认实现），原因在于 async_trait 过程宏没有实现完善，对于普通的函数直接跳过了，补充完善之后已经能够正常使用 as_any
  - 用户态异步系统调用库

## 20241105

- [x] 写代码
  - 增加 futex 实现逻辑
  - 增加 schedule syscall 相关的逻辑
  - 使用自己写的 async_trait 来实现动态分发，并修改原有的实现，部分接口还是使用到了 Box，这与 async_fs 中的实现有关
  - 更新了 rust 版本，naked_function 强制要求使用 naked_asm，导致一些依赖关系需要处理

## 20241104

- [x] 修 bug
  - 查找 cfs 调度器下执行完一个用户程序卡住的情况，没有出现错误，调度器找不到任务，因此一直没有输出，在进程的主任务结束之后，需要将进程结束，但目前没有增加这个操作，导致一直没有退出，在持续循环，但为什么在 fifo 的情况下可以正常工作？
  - 在 cfs 调度器的情况下正常了，但 fifo 调度器下出现了问题，问题在于 exit 发送了信号之后，进程在返回用户态之前没有检查是否需要进入到信号处理逻辑，增加处理逻辑后在三种调度器下均能够正常工作
  - 将 async_std 中提供的 JoinFutureHandle 提供 await 和 non-await 两种驱动方式，开发 unikernel app 可以使用方式，但不能同时使用，后续的进展是在任务管理模块设置更灵活的 feature，使得部分模块可以使用 await 驱动，另一部分模块可以使用 non-await 驱动。
- [x] 在 disscussion 中增加对上周工作的总结，完成过程宏的收尾工作
- [x] 写代码
  - 增加 futex 实现逻辑

## 20241103

- [x] 写代码
  - 继续完善与线程相关的接口
  - 写相关的文档
  - 查找代码中存在的 bug，目前在单核、宏内核模式下，使用 cfs 调度器存在 bug，执行 ls 后卡住，需要进一步查找问题

## 20241102

- [x] 写代码
  - 将普通返回值与 Future 返回值统一起来，并使用宏或 Deref
  - 使用宏并不能将这两者进行完全的统一，对于已有的代码，还是需要进行修改
  - 原本的方式，使用 `.lock()` 即可得到内部数据，使用宏则会变成 `fut!(.lock())`
  - 对于有返回值的函数，要保证在原来的函数中仍然能够使用，则必须保持返回值不变
  - Mutex 的接口已经完全同意
  - 以线程的形式 sleep 还存在问题，需要进一步定位，原因是使用了线程的接口后，进入 trampoline 关中断了，需要打开
- [x] 在 zcu102 的复现 uintr-rocket-chip

## 20241101

- [x] 写代码
  - 增加线程切换的逻辑
  - 将协程接口与线程接口结合起来，让原有代码能够兼容，并对代码进行重构
  - 增加使用线程实现的 sleep mutex 实现
  - 系统调用接口的完善可以推广到其他的接口，例如与任务相关的 yield 接口
  - 将 yield、sleep 等接口实现为协程、线程相统一
  - 将 wait_queue 相关的接口实现为协程、线程相统一

## 20241031

- [x] 写代码
  - 在任务模块增加线程相关的实现，需要考虑的问题是是否需要使用 feature 来使能
  - 将线程接口与中断抢占结合起来

## 20241030

- [x] 阅读论文：Efficient Microsecond-scale Blind Scheduling with Tiny Quanta
- [x] 讨论小论文
- [x] 组会

## 20241029

- [x] 写过程宏，简化 async trait 开发
  - 测试使用 Pin<Box<>> 的开销以及使用过程宏实现的方式的开销
  - 进行单元测试时，由于缓存的问题，导致先打开文件读写时的开销差距过大，即使显式关闭了文件之后也会出现过大的性能差距
  - 去掉了一些误差值，使用 async_trait 提供的宏的实现，具有明显的开销
- [x] 测试 Mutex 的开销

## 20241028

- [x] 阅读论文：Protect the System Call, Protect (Most of) the World with BASTION
- [x] 阅读论文：Efficient Microsecond-scale Blind Scheduling with Tiny Quanta
- [x] 写系统调用接口的描述文档
- [x] 写过程宏，简化 async trait 开发

## 20241027

- [x] 调研 crates.io 上的 syscall crates
  - 大部分只是在 Rust 提供直接使用 syscall 的库，没有对 syscall 的功能进行改造以及模块化的做法
  - open-coroutine-hook，使用了 hook 来调用自己实现的库，在这里可以使用已有的这种库，保证在 unikernel 的模式下，仍然能够在 C 程序中使用 Rust 协程的特性
- [x] 实现 syscall 接口模块
- [x] 阅读论文：Protect the System Call, Protect (Most of) the World with BASTION

## 20241026

- [x] 写专利交底书
- [x] 阅卷
- [x] 增加系统调用实现
  - 增加与信号机制相关的系统调用
  - 增加与 futex 相关的系统调用，futex 依赖 axtask 和 axfs 这两个模块，暂时先不进行修改
- [x] 将已有的修改进行完善，保证系统的性能
  - 进行单元测试，测试基于协程实现的 Mutex 以及基于线程实现的 Mutex
- [x] 写关于荷塘雨课堂的帮助文档

## 20241025

- [x] 听报告
  - 基于 feature 实现的组件化会导致 kernel backbone 变复杂
  - 使用类型擦除的指针 + trait 来实现组件化，类似于 Waker 的实现方式
- [x] 写专利交底书
- [x] 增加信号处理代码的实现

## 20241024

- [x] 解决模块化的问题，需要依赖注入，将函数直接注入到 executor 模块
  - `pub static UTRAP_HANDLER: LazyInit<fn() -> Pin<Box<dyn Future<Output = i32> + 'static>>> = LazyInit::new();`
  - 通过这种方式解决模块循环依赖问题
- [x] 实现信号处理
- [x] 写专利交底书

## 20241023

- [x] 修改调度方式，每个进程存在各自的调度器，切换进程会切换调度器
- [x] 组会，展开关于 async_trait 的讨论，最终的目标是扩展 async 的使用范围
- [x] 增加系统调用，遇到了在闭包中使用 async 关键字的问题，还需要了解这方面的支持
  - 除了网络、信号相关的系统调用，其他的系统调用大部分已经完善
  - 使用 cat 读取文件时，与原来的实现存在较明显的延迟，推测是由于 async_trait 导致的
- [x] 写专利交底书

## 20241022

- [x] 完善其他 Trap 处理，支持 busybox
  - 增加页错误处理
  - 增加信号处理，在此之前，需要先修改 executor 中的任务的调度方式，调度怎么与任务标识符系统结合起来
  - 遇到了模块循环依赖的问题，executor -> trampoline -> syscall -> executor，PLNTRY 没有模块化，不存在这个问题，暂时先绕过这个问题，不考虑模块化的事情
  - 增加了一些系统调用，但调度方式（在需要进行进程切换时）还需要修改

## 20241021

- [x] 写代码总结文档，整理仓库代码
- [x] 学习如何使用 github disscussion 写开发日志
  - 总结了上次关于 async_trait 的讨论
- [x] 写专利的交底书

## 20241020

- [x] 写总结文档，整理代码仓库

## 20241019

- [x] debug
  - 重写之后，虽然终端的输出符合预期，但引用计数不对，导致任务没有被回收，对于 CurrentTask、Waker 以及抢占和系统调用阻塞导致的让权，需要注意引用计数
  - 在切换 Executor 时需要切换地址空间
  - 在切换核时，也需要切换地址空间，在创建了用户态任务时，需要对用户态栈进行修改时，这时如果由于时钟中断导致了抢占切换到了其它核上，这时需要切换地址空间

## 20241018

- [x] 写完 trampoline，涉及到任务切换、内核 Trap、用户态 Trap 等逻辑均处理完成
  - 重新整理逻辑，将用户态任务与内核中的任务进行统一表示，将 Trap 处理的逻辑放入到 Future 中
  - 但用户态进入内核处理 Trap 时，如果产生了时钟中断需要进行抢占时，这时会出现问题，系统调用的让权处理也存在问题

## 20241017

- [x] 写 trap 代码
  - debug，将 trampoline 参数的 a0 寄存器设置成了 a1 寄存器，从而导致进入到 trampoline 时，进入到了错误的分支，从而进入到了 wfi 的处理逻辑
  - 修正了 gp、tp 等寄存器的保存与恢复后，出现了 StorePageFault 错误
  - 修改了 trampoline 中的逻辑后，能够把睡眠锁、中断这些逻辑正常跑通了，用户态的逻辑暂时未进行验证
- [x] 重新组织模块之间的依赖，以及 feature 的选择

## 20241016

- [x] 修改 trap 代码
  - debug

## 20241015

- [x] 修改 trap 实现逻辑
  - 使用跳板进行统一切换

## 20241014

- [x] 修改小论文
- [x] 写代码
  - 写跳板模块，为 trap_frame 增加 urestore 函数，从内核返回用户态
- [x] 修 bug，创建了 memory_set 后，其中的 owned_mem 被清空了
  - 可能的原因是因为修改了上下文的切换方式，导致进入内核后，栈的位置不正确，修改了栈的位置后，已经能够正常执行系统调用并返回

## 20241013

- [x] 修改小论文

## 20241012

- [x] 修改 axtrap 实现
  - 作为一个任务，与其他的任务结合起来

## 20241011

- [x] 修改 FileIO trait
  - 在为与文件相关的系统调用实现 FileIO trait 时，遇到了问题，还是 async 函数着色的问题，由于函数着色导致的问题需要很大的人工成本进行代码重构
  - 需要在尽量不改变接口的情况下达到与协程的兼容
  - 核心的问题是由于 Mutex 的改造导致
  - 暂时不再进行手动的处理，直接使用 async_trait 库，其中使用到了 Pin、Box 等，可能不是 zero_cost
  - 将系统调用、中断、异常处理函数用异步的形式实现后，但是没有实际的运行，导致产生时钟中断后没有更新定时器
  - 需要在进入到处理函数之后，运行处理的协程
  - 使用了空的 cx 使中断处理函数运行起来，已经可以基本运行了，但任务调度还没有统一起来，在处理系统调用时，一旦阻塞之后，不会让权执行其他任务

## 20241010

- [x] 写 async_executor 模块
  - 初始化用户任务，进入用户态
- [x] 修改 FileIO trait 的定义

## 20241009

- [x] 修改 axmem 实现
  - 在 trait 中使用 async 关键字，编译器会产生警告，并且使用 Box、Arc 相关的指针时，会提示 cannot be made into an object
- [x] 组会
- [x] 定义系统调用的同步接口与异步接口
- [ ] 实现 async_executor 模块

## 20241008

- [x] 实现 async_iter，参考了 async-std 中的实现，直接自定义了一套实现，core 中提供的 async_iter 还不稳定
- [x] 模块化 async_io、async_vfs、async_fs、async_std，增加相应的 README
- [x] 画图
- [x] 修改 axmen 中的实现

## 20241007

- [x] 解决重复获取锁的 bug
  - 在调用 cx.waker().wake() 唤醒任务之前，如果获取了锁，需要先将锁释放掉，否则一旦 wake，其他的核上执行时，会重新获取这个锁，与上下文保存的问题一致

## 20241004

- [x] 写 fs/shell 测试
  - stdin 存在问题，当没有从缓冲区中读取到数据时，会返回 pending，将任务阻塞，但此时没有中断来唤醒这个任务，buf_reader 存在问题，没能读出数据

## 20241003

- [x] 修改 spawn 接口，去掉了 Send 约束
- [x] 尝试实现异步迭代器

## 20241001

- [x] 单元测试 async_fs

## 20240930

- [x] 讨论小论文修改
- [x] async_fs 模块修改完毕，使用协程接口实现了 fatfs
- [x] 对协程实现的 fatfs 进行单元测试，在 async 中 使用 &str，编译器提示生命周期问题，参考了 future_rs/future_task 中的定义，去掉了 Send trait 的约束，经过初步的测试，能够正常的读取文件目录

## 20240929

- [x] 写 async_fs 模块，进行单元测试

## 20240928

- [x] 写代码
  - async_io 模块
  - async_vfs 模块，测试 vfs 模块

## 20240927

- [x] 写代码
  - 使用 async_io 中的接口实现了 stdio，实现了 async 版本的打印
  - 继续完善 async_io，修改完一处接口，其余的整个模块都需要重新定义

## 20240926

- [x] 面试
- [x] 写代码
  - 解决的问题，Mutex 修改后，怎么保证其他模块的代码更加优雅
  - 先把用户态的程序跑起来，搭建起基础的框架，再看怎么对各个模块进行修改，由于需要文件系统，但修改了 io 之后，无法编译
  - 重新定义 async_io 中的接口

## 20240925

- [x] 重构代码
  - 修改了 axsync 中的 Mutex 实现后，所有用到了 Mutex 的模块都得进行修改
  - 将代码修改成 async 之后，报错重复定义 start_signal_trampoline，目前先将其注释掉，跳过这个问题，应该是与依赖相关
  - 在 user_boot 中初始化文件系统，并尝试创建用户程序
- [x] 组会

## 20240924

- [x] 重构代码
  - axtask 支持抢占，并且支持能够在 SMP 上运行
  - 将 WaitQueue、TimerQueue 从 axtask 模块中拆分出来，在使用了泛型的数据结构时，字段的偏移会被编译器调整，taskctx 模块 lib.rs 中定义的方法存在 bug

## 20240923

- [x] 改论文
- [x] 重构 axtask 模块，目前要解决的问题：
  - 支持 C 程序：这个目标比较遥远
  - 抢占：按照之前在 AsyncStarry 中的实现进行

## 20240922

- [x] 读论文：INTOS: Persistent Embedded Operating System and Language Support for Multi-threaded Intermittent Computing
- [x] 改论文

## 20240921

- [x] 面试
- [x] 改论文

## 20240920

- [x] 面试
- [x] 重构 axtask 模块

## 20240919

- [x] 准备面试

## 20240918

- [x] 写 c 程序与 Rust Future 的兼容方案
- [x] 阅读博客：[Why Async Rust](https://www.tisonkun.org/2023/11/06/trans-why-async-rust/)
- [x] 组会
- [x] 重构 axtask 模块
- [x] 写关于协程的理解文档
- [x] 刷算法

## 20240917

- [x] 过节
- [x] 整理代码
  - 尝试在 c 程序中使用 sleep 来实现协程任务切换
  - 整理兼容层实现方案

## 20240916

- [x] 讨论 taic 论文
- [x] 重写 axstd 模块
  - stdin、stdout
  - 使用原始的 poll 函数实现了 stdout
  - 使用 async 的方式实现了 Mutex

## 20240915

- [x] 重写 axstd 模块
  - 不一定需要严格按照 Future trait 的实现来，也可以自定义 poll 函数，参数可以不同，核心的理念是 everything is future
  - 重构了 Mutex 结构，按照 Future 的形式进行

## 20240914

- [x] 参加项目本子修订
- [x] 重构 axtask 模块
  - 组件化 Future 构建
  - 将 WaitQueue 的接口改造成返回 Future 的形式

## 20240913

- [x] 重写 async_axstd 模块

## 20240912

- [x] 重写 axtask 模块
  - wait_queue 重写
  - 自动释放任务，不需要使用单独的 gc_task 来释放任务
- [x] 实现 async_axio 模块
  - 将 async-std 中的 io 模块迁移至此
- [x] 重写 async_axstd 模块
  - 将 Mutex 实现为 async 的形式

## 20240911

- [x] 组会
- [x] 重写 axtask 模块
  - executor 直接结合地址空间
  - timer 和 wait_queue 使用 waker 来实现
  - 省略任务状态，直接复用协程的 pending 和 ready 状态，子任务的 pending 和 ready 状态足够表示整个任务的状态

## 20240910

- [x] debug
  - 修改了 gc_task 的实现，以及确保任务的上下文切换正确的情况下，仍然出现了跑飞的情况，只能假设在其他的模块出现了问题，最有可能的是 axprocess 中与信号处理相关的模块
- [x] 这个 bug 目前没有找到问题在哪里，只能绕过这个问题，开始着手设计实验的部分，暂时使用局部队列来进行实验
  - 测试调度的开销，这个需要对比协程以及线程的实现，因此，可能需要对 axtask 模块进行重写，来支持 unikernel 下的测试
  - 而其他的与异步 IPC 以及异步系统调用相关的实现，可能也需要对 axprocess 进行修改
- [x] 写实验方案
  - 发现写不出来什么内容，并且需要对代码进行重构或者重写一个内核

## 20240909

- [x] debug
  - 分析调度器队列的相关操作的顺序
  - 在上下文切换的时候，使用了一把大锁，但还是出现了跑飞的情况
  - 对上下文切换完成后，对寄存器信息进行对比，并且增加了打印任务切换的日志后，发现可能是 gc -> gc 的切换导致了出现问题

## 20240908

- [x] debug
  - 控制器使用的全局队列对缓存局部性影响较大，会影响性能
  - 在进行上下文切换时，对任务的状态进行了上锁，但是还是出现了跑飞的情况

## 20240907

- [x] 修负载均衡 bug
  - 在 switch_post 函数中将 prev_task 放入到就绪队列中仍然出现错误，可能的原因是 wakeup_task 的操作没有保证顺序
  - gc 调用的 current_processor 来清空，当任务被迁移时，可能会产生问题
  - 与 ZYJ 讨论，修改之后还是没有找到问题
  - 使用 gdb 调试没有找到跑飞的地方

## 20240906

- [x] 刷算法
- [x] 修 bug

## 20240905

- [x] 修改 starry 负载均衡冲突
- [x] 刷算法

## 20240904

- [x] 修改小论文
  - 画图
- [x] 组会
- [x] 修改学期计划

## 20240903

- [x] 修改小论文

## 20240902

- [x] 修改小论文
  - 完善 related work 部分

## 20240901

- [x] 修改小论文

## 20240831

- [x] 整理代码
- [x] 修改小论文

## 20240830

- [x] debug
  - 使用最新的 starry，以及 qemu 控制器，发现仍然存在同样的问题，打印了与 moic 相关的日志信息后，发现产生 mmu 访问 reject 是在访问 OS 控制块时出现
  - 访问 moic 定义的任务控制块时，出现读写错误，原因是没有将虚拟地址转化称物理地址
  - 增加了地址映射后，没有出现 mmu 访问 reject，在单核的情况下没有出现错误，但开启多核之后，两个核执行到了同一个任务？问题在于硬件提供了负载均衡，当前任务唤醒任务将其增加到控制器中，其他核会马上取出被唤醒的任务，在 yield 时，也会出现相同的现象，导致任务的上下文不会被正确保存
  - 不使用硬件的负载均衡功能后，monolithic 的测试能够正常运行，后续还需要在代码中增加对硬件负载均衡的适配
  - 修改任务定义后，使用 moic 调度器也能正常工作，但是不使用负载均衡后，不能运行 redis 了，还需要增加抢占功能

## 20240829

- [x] debug
  - 使用原来的任务定义，但使用 qemu 控制器来调度，也存在错误，因此，出现问题可能是本来的实现，还是由于缓存的问题

## 20240828

- [x] 组会
- [x] debug（monolithic 模式下，使用 moic 调度器出现内核页错误）
  - 查看 qemu 的日志，在内核下访问了用户栈的内存，出错的代码在 axprocess 中的 stdin 的位置

## 20240827

- [x] 测试 starry monolithic 的功能正确性
  - 执行的结果肉眼可见的比之前慢，可能是记错了，但原本的测试也差不多的速度，问题应该不在修改的代码中，没有使用 img，ramfs
  - 使用 ramfs 会卡住，出现错误，不适用则能够正常通过测试
  - make pre_update 后能够通过测试
  - monolithic 模式下使用 moic 调度器会出现奇怪的页错误，在 unikernel 模式下，吞吐量是 cfs 调度器的两倍，但是这两者的比较意义不大，moic 相对于 cfs，有些特性没有使用

## 20240826

- [x] 修 starry 的 bug
  - 代码逻辑变简单了，但还是出现了奇怪的问题，在每次执行 prepare_to_wait 之后，没有将任务的状态修改为线程，因为内存布局的问题导致判断错误，ContextType 的大小为 1，但是在 Context 中为了对齐，会将其设置为 8 字节，修改后读取的值不正确，因此会产生错误的任务切换

## 20240824

- [x] 整理文档
- [x] 刷算法

## 20240823

- [x] 刷算法
- [x] 修 starry 的 bug
  - 问题在于 “用户态线程对应的内核线程的栈”，目前栈的管理仍然是比较混乱的，需要梳理好 yield、preempt 在 unikernel、monolithic 模式下的区别

## 20240822

- [x] 阅读 linux kernel Architecture
- [x] 面试
- [x] 刷算法

## 20240821

- [x] 阅读 linux 内核设计与实现
- [x] 刷算法

## 20240820

- [x] 检查论文语法错误
- [x] 完成投稿
- [x] 修改 taic 论文
- [ ] 修改 starry
  - 修改其中的错误，没有找到问题
  - 最主要的问题是如何验证上下文切换的代码是否正确，似乎可以写一个类似于 green thread 那样的模拟器，来验证代码是否正确
  - 还是重构代码，从根源上斩断问题的来源

## 20240819

- [x] 修改 starry
  - 使用了 moic 硬件来提供调度，初步将 TaskMeta 与 AxTask 结合起来
  - unikernel 模式下可以正常工作，可以运行 monolithic，但与控制器交互时，出现了访问内存错误，问题尚不明确
- [x] 面试
- [x] 检查论文语法错误
- [x] 刷算法题

## 20240817

- [x] 刷面经

## 20240816

- [x] 刷算法题
- [x] 改 starry
  - cfs 调度器下，出错，现象是指针跑飞了，原因大概率是因为上下文嵌套导致的 bug，但 fifo 能够正常工作，暂时不进行处理了
  - 结合控制器
- [x] 刷面经

## 20240815

- [x] 性能测试
  - 测试栈分配和回收的开销
  - 测试调度器的开销
  - 测试线程上下文保存的开销
  - 测试上下文恢复的开销
  - 新增 stat feature 来统计数据
  - 预分配栈，优化栈切换的开销
  - 与用户态相关的部分还存在 bug
- [x] 刷算法题

## 20240814

- [x] 组会
- [x] 修改学期计划
- [x] 阅读论文：CPU Inheritance Scheduling、Efficient Scheduler Live Update for Linux Kernel with Modularization
- [x] 整理文档
- [x] 思考性能测试

## 20240813

- [x] 整理文档
- [x] 整理论文格式

## 20240812

- [x] 学期初交流
- [x] 搜集会议信息
- [x] 整理学期计划
- [x] 整理文档
