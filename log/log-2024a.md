# 用于记录日常

## 20240925

- [x] 重构代码
  - 修改了 axsync 中的 Mutex 实现后，所有用到了 Mutex 的模块都得进行修改
  - 将代码修改成 async 之后，报错重复定义 start_signal_trampoline，目前先将其注释掉，跳过这个问题，应该是与依赖相关
  - 在 user_boot 中初始化文件系统，并尝试创建用户程序
- [x] 组会

## 20240924

- [x] 重构代码
  - axtask 支持抢占，并且支持能够在 SMP 上运行
  - 将 WaitQueue、TimerQueue 从 axtask 模块中拆分出来，在使用了泛型的数据结构时，字段的偏移会被编译器调整，taskctx 模块 lib.rs 中定义的方法存在 bug

## 20240923

- [x] 改论文
- [x] 重构 axtask 模块，目前要解决的问题：
  - 支持 C 程序：这个目标比较遥远
  - 抢占：按照之前在 AsyncStarry 中的实现进行

## 20240922

- [x] 读论文：INTOS: Persistent Embedded Operating System and Language Support for Multi-threaded Intermittent Computing
- [x] 改论文

## 20240921

- [x] 面试
- [x] 改论文

## 20240920

- [x] 面试
- [x] 重构 axtask 模块

## 20240919

- [x] 准备面试

## 20240918

- [x] 写 c 程序与 Rust Future 的兼容方案
- [x] 阅读博客：[Why Async Rust](https://www.tisonkun.org/2023/11/06/trans-why-async-rust/)
- [x] 组会
- [x] 重构 axtask 模块
- [x] 写关于协程的理解文档
- [x] 刷算法

## 20240917

- [x] 过节
- [x] 整理代码
  - 尝试在 c 程序中使用 sleep 来实现协程任务切换
  - 整理兼容层实现方案

## 20240916

- [x] 讨论 taic 论文
- [x] 重写 axstd 模块
  - stdin、stdout
  - 使用原始的 poll 函数实现了 stdout
  - 使用 async 的方式实现了 Mutex

## 20240915

- [x] 重写 axstd 模块
  - 不一定需要严格按照 Future trait 的实现来，也可以自定义 poll 函数，参数可以不同，核心的理念是 everything is future
  - 重构了 Mutex 结构，按照 Future 的形式进行

## 20240914

- [x] 参加项目本子修订
- [x] 重构 axtask 模块
  - 组件化 Future 构建
  - 将 WaitQueue 的接口改造成返回 Future 的形式

## 20240913

- [x] 重写 async_axstd 模块

## 20240912

- [x] 重写 axtask 模块
  - wait_queue 重写
  - 自动释放任务，不需要使用单独的 gc_task 来释放任务
- [x] 实现 async_axio 模块
  - 将 async-std 中的 io 模块迁移至此
- [x] 重写 async_axstd 模块
  - 将 Mutex 实现为 async 的形式

## 20240911

- [x] 组会
- [x] 重写 axtask 模块
  - executor 直接结合地址空间
  - timer 和 wait_queue 使用 waker 来实现
  - 省略任务状态，直接复用协程的 pending 和 ready 状态，子任务的 pending 和 ready 状态足够表示整个任务的状态

## 20240910

- [x] debug
  - 修改了 gc_task 的实现，以及确保任务的上下文切换正确的情况下，仍然出现了跑飞的情况，只能假设在其他的模块出现了问题，最有可能的是 axprocess 中与信号处理相关的模块
- [x] 这个 bug 目前没有找到问题在哪里，只能绕过这个问题，开始着手设计实验的部分，暂时使用局部队列来进行实验
  - 测试调度的开销，这个需要对比协程以及线程的实现，因此，可能需要对 axtask 模块进行重写，来支持 unikernel 下的测试
  - 而其他的与异步 IPC 以及异步系统调用相关的实现，可能也需要对 axprocess 进行修改
- [x] 写实验方案
  - 发现写不出来什么内容，并且需要对代码进行重构或者重写一个内核

## 20240909

- [x] debug
  - 分析调度器队列的相关操作的顺序
  - 在上下文切换的时候，使用了一把大锁，但还是出现了跑飞的情况
  - 对上下文切换完成后，对寄存器信息进行对比，并且增加了打印任务切换的日志后，发现可能是 gc -> gc 的切换导致了出现问题

## 20240908

- [x] debug
  - 控制器使用的全局队列对缓存局部性影响较大，会影响性能
  - 在进行上下文切换时，对任务的状态进行了上锁，但是还是出现了跑飞的情况

## 20240907

- [x] 修负载均衡 bug
  - 在 switch_post 函数中将 prev_task 放入到就绪队列中仍然出现错误，可能的原因是 wakeup_task 的操作没有保证顺序
  - gc 调用的 current_processor 来清空，当任务被迁移时，可能会产生问题
  - 与 ZYJ 讨论，修改之后还是没有找到问题
  - 使用 gdb 调试没有找到跑飞的地方

## 20240906

- [x] 刷算法
- [x] 修 bug

## 20240905

- [x] 修改 starry 负载均衡冲突
- [x] 刷算法

## 20240904

- [x] 修改小论文
  - 画图
- [x] 组会
- [x] 修改学期计划

## 20240903

- [x] 修改小论文

## 20240902

- [x] 修改小论文
  - 完善 related work 部分

## 20240901

- [x] 修改小论文

## 20240831

- [x] 整理代码
- [x] 修改小论文

## 20240830

- [x] debug
  - 使用最新的 starry，以及 qemu 控制器，发现仍然存在同样的问题，打印了与 moic 相关的日志信息后，发现产生 mmu 访问 reject 是在访问 OS 控制块时出现
  - 访问 moic 定义的任务控制块时，出现读写错误，原因是没有将虚拟地址转化称物理地址
  - 增加了地址映射后，没有出现 mmu 访问 reject，在单核的情况下没有出现错误，但开启多核之后，两个核执行到了同一个任务？问题在于硬件提供了负载均衡，当前任务唤醒任务将其增加到控制器中，其他核会马上取出被唤醒的任务，在 yield 时，也会出现相同的现象，导致任务的上下文不会被正确保存
  - 不使用硬件的负载均衡功能后，monolithic 的测试能够正常运行，后续还需要在代码中增加对硬件负载均衡的适配
  - 修改任务定义后，使用 moic 调度器也能正常工作，但是不使用负载均衡后，不能运行 redis 了，还需要增加抢占功能

## 20240829

- [x] debug
  - 使用原来的任务定义，但使用 qemu 控制器来调度，也存在错误，因此，出现问题可能是本来的实现，还是由于缓存的问题

## 20240828

- [x] 组会
- [x] debug（monolithic 模式下，使用 moic 调度器出现内核页错误）
  - 查看 qemu 的日志，在内核下访问了用户栈的内存，出错的代码在 axprocess 中的 stdin 的位置

## 20240827

- [x] 测试 starry monolithic 的功能正确性
  - 执行的结果肉眼可见的比之前慢，可能是记错了，但原本的测试也差不多的速度，问题应该不在修改的代码中，没有使用 img，ramfs
  - 使用 ramfs 会卡住，出现错误，不适用则能够正常通过测试
  - make pre_update 后能够通过测试
  - monolithic 模式下使用 moic 调度器会出现奇怪的页错误，在 unikernel 模式下，吞吐量是 cfs 调度器的两倍，但是这两者的比较意义不大，moic 相对于 cfs，有些特性没有使用

## 20240826

- [x] 修 starry 的 bug
  - 代码逻辑变简单了，但还是出现了奇怪的问题，在每次执行 prepare_to_wait 之后，没有将任务的状态修改为线程，因为内存布局的问题导致判断错误，ContextType 的大小为 1，但是在 Context 中为了对齐，会将其设置为 8 字节，修改后读取的值不正确，因此会产生错误的任务切换

## 20240824

- [x] 整理文档
- [x] 刷算法

## 20240823

- [x] 刷算法
- [x] 修 starry 的 bug
  - 问题在于 “用户态线程对应的内核线程的栈”，目前栈的管理仍然是比较混乱的，需要梳理好 yield、preempt 在 unikernel、monolithic 模式下的区别

## 20240822

- [x] 阅读 linux kernel Architecture
- [x] 面试
- [x] 刷算法

## 20240821

- [x] 阅读 linux 内核设计与实现
- [x] 刷算法

## 20240820

- [x] 检查论文语法错误
- [x] 完成投稿
- [x] 修改 taic 论文
- [ ] 修改 starry
  - 修改其中的错误，没有找到问题
  - 最主要的问题是如何验证上下文切换的代码是否正确，似乎可以写一个类似于 green thread 那样的模拟器，来验证代码是否正确
  - 还是重构代码，从根源上斩断问题的来源

## 20240819

- [x] 修改 starry
  - 使用了 moic 硬件来提供调度，初步将 TaskMeta 与 AxTask 结合起来
  - unikernel 模式下可以正常工作，可以运行 monolithic，但与控制器交互时，出现了访问内存错误，问题尚不明确
- [x] 面试
- [x] 检查论文语法错误
- [x] 刷算法题

## 20240817

- [x] 刷面经

## 20240816

- [x] 刷算法题
- [x] 改 starry
  - cfs 调度器下，出错，现象是指针跑飞了，原因大概率是因为上下文嵌套导致的 bug，但 fifo 能够正常工作，暂时不进行处理了
  - 结合控制器
- [x] 刷面经

## 20240815

- [x] 性能测试
  - 测试栈分配和回收的开销
  - 测试调度器的开销
  - 测试线程上下文保存的开销
  - 测试上下文恢复的开销
  - 新增 stat feature 来统计数据
  - 预分配栈，优化栈切换的开销
  - 与用户态相关的部分还存在 bug
- [x] 刷算法题

## 20240814

- [x] 组会
- [x] 修改学期计划
- [x] 阅读论文：CPU Inheritance Scheduling、Efficient Scheduler Live Update for Linux Kernel with Modularization
- [x] 整理文档
- [x] 思考性能测试

## 20240813

- [x] 整理文档
- [x] 整理论文格式

## 20240812

- [x] 学期初交流
- [x] 搜集会议信息
- [x] 整理学期计划
- [x] 整理文档
