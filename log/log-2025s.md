# 用于记录 2025 春季学期日常

## 20250220

- [x] 阅读 embassy_preempt
  - 测试结果与 c 实现的 ucosii 存在一点差距，是否可以达到相同性能甚至更优
  - 测试中关于 embassy 的结果是否准确，embassy 也有优先级的实现
- [x] 修改 tokio 源码中的调度部分
  - 学习 cargo bench
  - 使用 tokio 提供的已有测试，得到 baseline（进入 benchs 目录，执行 `cargo bench --bench rt_multi_threaded`）
    - x86 架构下ok，但在 riscv 架构下（增加编译选项 `--target riscv64gc-unknown-linux-gnu`）链接出错，先声明环境变量 `export CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_GNU_LINKER=riscv64-unknown-linux-gnu-gcc`
    - 最后的编译指令为：`export CARGO_TARGET_RISCV64GC_UNKNOWN_LINUX_MUSL_LINKER=riscv64-linux-musl-gcc` + `cargo bench --bench rt_multi_threaded --target riscv64gc-unknown-linux-musl --no-run`
  - 学习 criterion 社区提供的 benchmark 测试工具，使用了 gnuplot 进行画图，可以直接得到相关的数据
  - 测试在 linux 中运行出现问题，报错没有 libgcc_s.so.1 动态库，将文件复制进去后，可以成功运行测试，但是没有找到相应的结果
  - 将 linux 内核也用 linux-musl 编译后，无法启动 4~7 cpu
    - 跟踪 opensbi 中的 store access fault 处理发现，错误来自 M 模式，而只有 opensbi 运行在 M 模式，再对比前后的结果，opensbi 的修改仅仅限于编译器从 gnu 切换至了 musl，但是仅仅切换 git log，没有清空 opensbi 的缓存，因此导致编译器仍然使用了 musl 编译器，导致了这个错误，彻底清除 opensbi 缓存，并使用 musl 编译之后，能够正常拉起 8 个 CPU
    - 将 benchmark 放入到 rootfs 之后还是遇到了之前相同的问题，决定把这个问题解决，出现错误的原因是访问到了 lowmem 的起始地址（0xffffffd800000000），先搞清楚这个地址是不是只能由 opensbi 固件来访问，不能由 supervisor 模式下的 linux 来访问

## 20250219

- [x] 阅读 tokio 源码
  - 一堆的闭包来回嵌套，如果有人看到这个评论的话，我建议是别看 tokio 的源码
- [x] 阅读 yzw、snh、yck 的 embassy_preemmt
  - 在嵌入式系统中每个任务都是不会结束的，因此不需要回收空间，对于任务而言，只需要静态分配即可
  - 他们的设计直接让每次中断都发生在任务执行的过程中，执行器本身的代码处于临界区中

## 20250218

- [x] 阅读 tokio 源码
  - tokio 与 IO 相关的核心实现在单独的 mio 仓库中，mio 提供了与底层操作系统的交互的 IO 类型
  - 可以参考 tokio 中的 async_io 函数的实现，来定义 vfs 的接口，这个工作可以排在写完论文之后

## 20250217

- [x] 第一次组会
- [x] 翻译 tokio blogs
- [x] 阅读 tokio 源码
