## A coroutine framework for transaction processing

### Abstract

协程适应事务模型存在的缺点：

- 调度程序线程和工作线程之间的负载不平衡，额外的调度程序线程会产生同步开销
- 定期换出协程避免死锁，但是会增加挂起的事务，增加冲突率
- 支持的功能只有 yield、await 等，不能及时灵活的控制

SGPM 的特点：

- 消除了调度程序线程和周期性协程切换
- 提供多种协程调度策略

### Introduction

- 协程是 lightweight thread，复用线程，保存上下文和调用栈
- 协程的调度可以由用户自己控制，而不是需要像线程一样的抢占机制

研究表明传统的 OLTP 在线事务处理系统将大量的 CPU 时间用于等待

用第三方协程库实现协程事务架构，存在缺点：需要额外的线程来管理协程调度

1. 需要维护协程之间的调用栈信息
2. 周期性的从线程切换到协程
3. 将可用线程分配给协程

1 和 2 不需要太过考虑，因为只会在主线程中进行调度，通过合理的并发控制就不会导致死锁；将调度和执行分离可能会成为性能瓶颈。

**第三方的协程包只会提供基础的调度功能，会使得无法灵活控制事务或操作的重新执行时间。**

**并发性远大于并行性，未估计冲突事务的交换时间，则会导致性能损失。**

SGPM 由 GPM 发展过来，优势在于：

- 模型简化：通用线程取代了原先的 Processor、Machine、Local Queue；删除了调度线程，减少了调度线程和工作线程之间的同步开销
- 调度更加灵活：5 种调度策略，对应于协程动态返回的 5 信号对象。

SGPM 的的 Thread Queue Size 是重要的参数。

### Background

冲突处理机制

- Wound-wait 机制：忙等，可能会出现死锁，需要采用死锁避免措施
- No-wait、wait-die 机制：破坏了产生死锁的保持并等待条件，但是已经执行的语句会重新执行（产生冲突重新开始执行；等验证冲突结束之后重新执行）



