---
tags: []
parent: 'User Level IPC and Device Management in the Raven Kernel'
collections:
    - IPC
version: 12978
libraryID: 1
itemKey: 2C4FIX3G

---
# User Level IPC and Device Management in the Raven Kernel

## Abstract

网络带宽和存储设备对底层 OS 服务提出了更高的性能要求。需要以一种高效的方式在设备和用户程序之间传输数据。

Raven kernel 使用了用户态实现的技术，减少了内核的干预。实现了用户态 send/receive/reply 通信实现，最好情况下不需要内核参与，最坏情况下需要两次内核参与。通常情况下，每两次 send/receive/reply 需要一次内核参与。在用户态完全支持设备驱动，减少复制和上下文切换开销。

## Introduction

纯内核介入的架构（Mach、V、使用 continuations 优化）需要大量开销。

文章作者实现了一个基于共享内存多处理器的轻量级内核。在用户态完成线程、IPC 和设备管理。任务和虚拟内存管理在 supervisor 内核中。提供多线程并行应用程序一个轻量级的环境。

在基于多线程并行和设备中断频率高的环境下，运行这些应用的上下文切换开销巨大。

文章作者将使用率较高的内核服务迁移到用户态，减少了用户态/内核之间的交互。包括以下几项技术：

1.  用户态线程调度
2.  用户态中断处理：允许中断处理程序直接向上调用到用户空间，设备驱动可完全在用户态实现
3.  用户态 IPC：client 与 server 之间共享内存，消除内核中的数据复制
4.  底层同步原语：提供简单机制允许事件从一个地址空间传递到另一个地址空间，通过适当的硬件，远程处理器中断完全可以在用户态实现。

## Overall kernel design

Raven kernel：轻量级微内核、共享内存多处理器、supervisor kernel + user level library；与 QNX 类似，supervisor kernel 提供了一组抽象，在这组抽象的基础上可实现更加复杂的服务。但 Raven kernel 利用了对称多处理器和用户态设计技术的优点。

内核提供了两个主要的抽象：

1.  任务：创建、销毁、调度（地址空间切换），一个任务由一个地址空间组成，可以在一个或多个处理器上运行。
2.  虚拟内存：虚拟内存分配和映射通过系统调用

其他的服务在用户态提供，应用程序通过 inline macros 或 procedure calls 访问这些服务，而不是陷入内核：

1.  线程：可以在处理器之间抢占。用户态的线程调度器使用 per-task 共享数据结构和系统调用与 supervisor kernel 进行通信和协调。per-task 共享数据维护了几个字段使得用户态调度器与 supervisor kernel 能够做出调度决策而不用跨越用户/内核地址空间界限。理想情况下，线程可以在没有内核干预的情况下在处理器之间迁移。
2.  信号量同步：协调本地或远程地址空间中的线程
3.  IPC：通过共享内存
4.  设备管理

MVME188 硬件能够高效的将中断转发给系统中的远程处理器。Raven kernel 使用了这个硬件来用于任务调度（使用中断通知空闲 CPU 调度）和 IPC 交互（使用中断通知正在运行目标接收任务的处理器）。空闲处理器不会主动扫描任务列表，而是等待任务通过中断传递给空闲处理器。

在 MVME188 提供的中断机制之上，Raven kernel 建立了异步任务信号发送设施，可以异步的发送信号消息给另外的任务（与 Cheritons 的 address-valued signal 硬件相似）。信号消息由两个字的结构组成，一个指明信号消息类型，另一个指明消息数据。每个用户态调度器维护 FIFO 来存储信号消息，针对信号消息类型实现了一组信号处理程序。在收到信号消息后，信号处理程序将会被调用。任务信号是 IPC 和信号量操作的基础。

任务通过非阻塞的用户库函数 task\_signal() 发送信号，这个函数通过发起远程软件中断来通知目的任务信号消息已经到达，避免了系统调用陷入内核。信号发送的三种方式：

1.  目的任务正在远程处理器上运行，直接发送中断给远程处理器
2.  目的任务不在远程处理器上运行，给空闲处理器发送中断
3.  目的任务不在远程处理器上运行，且没有空闲处理器，执行系统调用，并进行任务切换

## Interprocess communication

用户态 IPC 库提供了基于端口的同步 send/receive/reply 接口与异步 send/receive 接口。

send/receive/reply 接口允许 reply 阶段推迟一段时间，允许乱序。这些接口利用了用户态共享内存和任务信号发送机制来减少内核交互的频率。

同步和异步 IPC 使用不同的端口表，端口表在所有用户态任务之间共享。

端口描述符包含端口队列的状态、信号量来保证 client 与 server 之间的协调操作。

创建端口时，IPC 库搜索合适的端口表、空闲入口、分配相关的 FIFO 消息队列（消息数量和大小在创建时确定）。在创建端口后，使用端口下标来作为端口描述符。端口消息队列在 client 和 server 之间是一段共享的虚拟内存区域。

### IPC algorithm

IPC 分成两个部分。

1.  sender 和 receiver 之间的消息数据迁移（传统的在内核中维护的消息队列，消息数据必须编组必须经过内核），Raven kernel 将消息队列直接暴露给用户态地址空间，允许用户代码直接提交消息数据，receiver 能够直接访问消息队列中的数据。
2.  IPC 通知接收方消息已经到达，将控制权传递给被阻塞的接收方线程。

同步的 send/receive/reply 比异步更加复杂，client 上的 sender 需要阻塞等待 servers 的回复。最好情况下，同步与异步接口都不需要通知机制，最坏情况下，同步 IPC 需要两次通知，异步 IPC 则只需要一次通知。

1.  最好情况下，server 线程正在运行，它发现消息在等待，会马上将消息取出。
2.  当 server 线程阻塞，且没有消息等待时，需要唤醒 server。
3.  当消息队列满，不能接收额外的 client 消息，client sender 必须阻塞，当 server 清空消息队列时，需要通知阻塞的 client 消息队列中已经有足够的空间。

异步发送原语（至多一次通知或一次系统调用）：

1.  若没有空闲消息缓冲区，则阻塞在空闲链表的信号量上
2.  获取下一个空闲消息缓冲区，并复制消息
3.  当 send queue 之前为空，且 server 线程阻塞时，发送通知。否则不发送通知。

异步接收原语（至多一次通知）：

1.  如果没有等待的消息，则阻塞
2.  弹出下一个消息并复制到线程缓冲区中
3.  将消息缓冲区返回到队列中，并增加空闲链表的信号量，若发送线程在阻塞，则发送信号唤醒给 client

## Device driver management

用户态通过 kernel 中断派遣机制以及映射设备寄存器到用户态地址空间来注册硬件设备处理程序，当设备中断产生后，将会调用用户态的中断处理任务。

<span style="color: rgb(0, 0, 0)">Each interrupt generated by a device causes an upcall into user space. 需要从 kernel 切换到用户空间，比起直接在内核进行中断处理的开销大，但会存在以下好处：</span>

1.  不需要在 kernel 和用户地址空间之间复制数据
2.  在处理完中断后，可以继续在用户态地址空间中执行，允许用户程序继续处理数据。
3.  设备驱动可以动态加载/卸载，不需要复杂的动态链接
4.  设备可以在用户态实现，减少通信的开销和延迟

### Interrupt management

MVME188 中断管理硬件。内核来管理处理器中断使能寄存器，必须随用户态任务而移动（这句话的意思是类似于每个用户态任务都有自己的 ustatus）。

### User level preemption

中断抢占用户线程会造成调度事件发生。但被抢占的线程如果占用了 spin-lock，则会导致 CPU 资源浪费。文章的解决办法是在内核中设置了一个变量 lock\_count，当用户态尝试获取自旋锁时，变量自增。当中断发生时，内核中的变量如果非 0，则表示用户态的任务在临界区中，需要返回到临界区中，但会设置 upcall\_pending 来表示中断发生了，当退出用户态的临界区时，会检查 upcall\_pending 变量，如果设置了，则会切换上下文，进行抢占。lock\_count 与 upcall\_pending 变量需要原子操作，不能使用 spin-lock。

### Dispatching interrupts

中断派遣需要在 supervisor 和 user 级别实现，中断发生时，寄存器上下文保存到 user 的线程控制块中，supervisor kernel 的中断派遣者处理中断。如果中断是给用户态发送的，则会向上传递给合适的任务，用户态的中断派遣开始工作。

supervisor 中断派遣维护了一组可能的中断源以及中断处理函数地址的表。

1.  一些中断处理函数直接实现在内核中，中断派遣是直接通过函数调用进行。
2.  对于在用户态的中断处理函数，supervisor 派遣会检查合适的中断入口，如果当前执行的任务注册了中断处理，中断将向上传递给该任务（设置合适的中断向量位）。若当前正在执行的任务没有注册中断处理，其他任务注册了，则当前任务需要切换到注册了中断处理的任务。

### Handler functions and device access

设备寄存器必须映射到应用地址空间中，内核需要注册设备中断处理程序（设备初始化阶段完成）。当设备驱动结束时，中断处理函数必须移除，设备寄存器需要取消映射。

虚拟内存模块给用户程序提供了 vm\_map\_device 函数允许应用映射设备寄存器到用户态。vm\_unmap\_device 移除设备寄存器映射。

用户态例程管理设备中断处理函数的注册。调用者指明中断处理函数地址和中断向量，通过系统调用通知内核的 supervisor 中断派遣来注册新的中断处理函数，给指定的设备设置中断使能位。

用户态的中断处理函数无法被抢占，且不能执行线程或任务上下文切换。

## Performance

benchmarks

1.  最好情况下，42 微秒完成单次 send/receive/reply，无需 kernel 介入
2.  send/receive/reply 的平均时延为 90 微秒
3.  最坏情况下，145 微秒
4.  用户态中断处理程序的调用时延为 14 微秒

### Interprocess communication

server 创建能够容纳 20 个消息缓冲区的队列，一定数量的 server 线程监听端口的消息，一定数量的 client 线程发出消息。

#### Synchronous IPC performance

在单处理器上，一次通信需要切换两次地址空间，145 微秒时延。

在两个处理器上，不需要地址空间切换，但通知信号需要有远程中断机制发送。

client 和 server 的数量增加，IPC 的性能增加较小，在单处理器情况下，性能优化的好处在于缓冲区在用户态，不需要在内核与用户态之间复制数据，且多个 client 线程会先都往队列中放入数据再切换到 server 线程。

在多处理器环境下，IPC 性能反而下降，作者猜想的原因是 spin-lock 竞争和低级的调度策略。

#### Asynchronous IPC performance

在线程增多的情况下，存在轻微的性能影响。可能的原因是线程调度器的问题，且增加线程会增加上下文切换时栈和数据结构的数量，可能会影响缓存性能。

随着处理器增加，性能下降，可能也是因为 spin-lock 的影响。在真实环境下，可能影响会减小。

### Interrupt handling performance

1.  内核的中断处理：7.21微秒
2.  用户态注册了中断处理函数的任务在线时：7.21 微秒 \* 2
