[TOC]

# A Fast File System for UNIX

pdf 原文链接：[untitled (psu.edu)](https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=221BE7C2E6CC675A56DD5907EFA69D88?doi=10.1.1.114.9535&rep=rep1&type=pdf)

### 现状：UNIX 文件系统速度慢，不能满足许多应用需求

- inode 与 data 分离，导致从 inode 到 data 寻道需要花费很多时间
- 分配 data 块的方法不是最优的
- 尽管 fs 在创建的时候是按照最优的方法，但是在使用过程中，空闲块的组织方式将会变成完全随机

当前现状的改进措施：

- 将块大小从 512 扩大到 1024
- 专门有一个程序周期性的重新组织数据块的组织方式，使其恢复局部性
- 预分配一些数据块

### new fs

##### 组织方式

- 复制超级快防止灾难性损失

- data 块的大小为 4096 字节（最大的问题是 UNIX 文件系统里面很多是小文件，块越大，浪费的空间越大）

- 用 bitmap 替换 free list 的分配方式

- 柱面组的基本信息存放在偏移不同的地方

- 将一个 data 划分为一个或多个 fragment（在创建时已经确定了大小）


##### 执行 write 系统调用时会遇到三种情况：

- 已经分配给文件的空间还存在空闲的，足以容纳新的数据
- 文件没有碎片块，先填满已经分配的空间的空闲部分，之后再分配数据块，最后不足一个完整块则分配一个碎片
- 文件包含 1 个或多个碎片（碎片不足以容纳新的数据），若新数据 + 碎片块中的数据超过了一个完整块，则会分配一个新的完整块，并且将之前的碎片释放，之后重复上述第 2 种情况步骤；否则就分配碎片块

##### 性能比较

- 空间的浪费主要取决于 fragment 的大小（完整块节省的索引信息大小与维护 fragment 多出来的空间相抵消）
- 空闲块数目有下限，低于下限就会通过删除文件来维护这个下限（空闲空间保留的数据也被记录到浪费的部分）

##### 文件系统参数化（旧 fs 忽略了底层硬件参数，例如：大容量设备 / 交互设备的特性等信息）

- 根据设备的特性使其参数化，使得分配时可以很具配置选择最优方式
- 对于大容量设备，偏向与分配新的块与前一个块在同一个柱面；
- 根据参数计算出磁头移动的期望时间，响应中断和调度新的磁盘传输的期望时间，从而减少了等待磁盘自己定位的时间
- 参数不是固定的，可以修改以适配不同的处理器，即使初始化时不能最优，在运行时也可以修改

##### 布局策略

- 对于 inode 的分配，同一个目录中的 inode 分配到同一个柱面组，因此访问一个目录下的所有 inode 有一个小的稳定的上限（旧 fs 则每读取一个 inode 就需要一次磁盘传输）
- 目录分配采取不同的策略，新目录将会被放置在空闲 inode 数目多，已存在目录较少的柱面组
- 对于数据块的分配，会试图把所有的数据放在同一个柱面组中（缺点：导致大文件会用完整个柱面组，解决措施是间接块的数据放在不同的柱面组）
- 若请求分配确定编号的 block，若对应的 block 是空闲的，则会直接分配，若没有，则会分配旋转最近的空闲块（4级分配策略）
    - 同一柱面旋转最近的可用 block
    - 同一柱面无可用 block 时，则在同一柱面组
    - 同一柱面组如果没有空闲块，则会根据柱面组编号进行二次散列（因此要求 10% 的空闲空间）
    - 在所有柱面组中查找

##### 性能

- inode 分配策略有效，尤其是 list directory 等程序运行时
- 吞吐量与保留的空闲空间数量紧密相关
- 使用大块，每次需要分配的块少；对于分配每个字节的开销相同
- write 系统调用是异步的，read 系统调用是同步的，因此旧 fs read 比 write 慢，但是对于新 fs，由于 data 块的组织方式发生了变化，所以 read 时，寻道的时间已经被优化了
- 新 fs 中 分配的开销才是 write 比 read 慢的原因
- 新 fs 的性能主要受制于 men 到 men 之间的复制操作（从内核地址空间的缓冲区到用户地址空间的缓冲区）

##### 支持 long file name

- 用 directory entry 代替原先的 chunk

##### File locking

- 旧 fs 没有提供相关实现，进程同步文件使用独立的锁，有三个缺点：
    - 忙等
    - 系统崩溃留下的锁需要手动一处
    - 系统管理员创建文件，处理器会被强制使用其他的机制
- 使用了文件锁
    - hard lock
    - advisory lock（即使一个程序获取了文件的锁，其他的程序也可以访问文件）

##### Symbolic link

- 一个包含文件路径的文件，并为此增加了 3 个系统调用

##### Rename

- 支持普通文件和目录