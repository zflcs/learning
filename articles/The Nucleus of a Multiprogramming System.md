### The Nucleus of a Multiprogramming System

#### Abstract

* 层次化的操作系统扩展进程并发系统的结构和理念

#### Introduction

* 设计操作系统的一个重要原则：允许设计者改变系统控制操作的模式（这正是操作系统不允许的）

#### System Nucleus

* 关注并行系统的基础控制层面
  * 首先定义精准的进程概念
  * 然后定义同步原语
  * 最终讨论动态创建、控制、删除进程

#### Processes

* 将进程划分为内部进程和外部进程
  * 内部进程
    * 执行给定内存区域的可以相应一个或多个中断的程序
    * 有特定的名字
    * 其他进程可以通过名字来引用内部进程而不用知道内部进程的实际位置
  * 内部进程和程序的区别
    * 程序只是一些计算进程的指令的集合
    * 内部进程则是在给定区域执行这些指令
  * 系统区分外围设备、文档和外部进程
* 内部进程和外部进程的并发和通信
  * 通过具有完整的中断响应程序、控制输入输出、存储保护、以及中断的系统

#### Process Communication

* Dijkstra 设计的信号量机制并不能满足全部要求，某个进程会打破信号量的这个规则
* message buffering 机制作为进程通信的基本手段，系统核心管理一个 message buffering 池，管理每个进程的 message queue
  * send message
  * wait message
  * send answer
  * wait answer
* 多进程并发系统是动态的，进程可以随时产生和结束，进程并不知道其他进程是否存在，通过 wait message 机制可以让进程在收到消息时知道其他进程的存在
* 还可以通过 buffer 的建立作为进程通信会话创建的标志，允许一次性传递多个消息
* 系统核心必须要保证没有进程可以打断其他两个进程之间的通信，通过在 buffer 中保存 sender 和 receiver 的信息并检查实现
* 缓冲区排队，允许发送者不必等待接收者的处理，保证了效率
* 即使一个进程在与其他的进程处于通信中，这个进程也可以被移除，系统核心会保留其他进程的通信队列中与这个进程有关的消息，不会分发，当其他进程回复时，由系统核心将这个 buffer 回收到 buffer 池中
* message buffering 的主要缺点是引入了资源问题，池中的 buffer 是有限的，如果一个进程使用完了所有的 buffer，后续的进程通信将会被阻塞，因此自然需要限制进程可以使用的 message buffering 数量

#### External Processes

* 使用 send message 和 wait answer 两个原语实现内部进程和外部进程的通信
* 外部进程的创建源于内部进程，两者的区别仅仅是处理能力，内部进程可以代替同名的外部进程

#### Internal Processes

* 内部进程的创建源于另外的内部进程（应该就是类似于 fork + exec）
* 进程有选择自己的程序调度策略的自由

#### Process Hierarchy

* 父进程包含子进程，父进程作为子进程的操作系统？？？这样一种层次结构？？？
  `<img src = "../assets/层次结构进程.png">`
* 所有特权功能都由核心实现，没有任何内置策略
* 每个进程都有权控制子进程的调度和资源分配
* 核心唯一需要确定的是进程只会分配自己拥有的资源的子集给子进程，进程只能控制子进程的开始、结束、删除，当一个进程结束，其分配的资源会返回给父进程
* 进程的调度与进程在层次结构中的位置无关，每个进程都可以与其他进程进行通信
* 新的操作系统应该具备的特点
  * 可以通过修改其他的程序来实现，而不需要修改核心
  * 操作系统可以动态更换
  * 标准程序和用户程序不需要修改自身，即可在不同的操作系统上运行

#### 思考：

* message buffering 的机制，与之前的在 buffer 中记录 log 信息、进程 id 这样的想法是相同的，因此我觉得利用 log 是完全可行的
* 层次结构来管理进程，是否可以用到进程管理线程、线程管理协程
  * 进程管理线程，主要是给线程分配栈等资源，线程的调度怎么实现
