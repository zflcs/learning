## 怎么将底层的异步网卡驱动与 `smoltcp` 协议栈结合

### 网卡与 `smoltcp` 的接口

`smoltcp` 对于网卡，规定了需要实现 `Device` `trait`。这是 `smoltcp` 对底层网卡的接口规定。

### 异步网卡驱动与 `smoltcp` 中规定的同步接口如何结合

#### 网卡与协议栈的异步机制

异步主要是针对网卡的接收通道，当网卡缓冲区中没有数据时，当前任务阻塞，并让出 CPU，当网卡收到数据后，通过中断通知 CPU，在中断处理函数中将阻塞的任务唤醒，协议栈继续执行。

协议栈的执行通过 `iface_poll()` 这个函数，在这个函数中，最终会调用底层网卡实现的 `Device` `trait` 中实现的 `receive` 函数。`receive` 函数中检查网卡中有没有数据包，没有数据包就返回。

#### 目前存在的问题

1. `smoltcp` 同步的接口没提供协程的 `cx` 和 `waker`，在运行任务时，无法通过 `cx` 或 `waker` 拿到任务本身的信息，从而无法向 `ATSINTC` 中断控制器中注册阻塞任务。
2. `embassy-net` 协议栈中对于底层的驱动也同样规定了 `receive` 和 `transmit` 接口，但提供了 `cx`，在运行协程时，能够通过 `cx` 拿到任务本身的信息。但它的内部实现可能是存在问题的，目前没有仔细去查问题

#### 异步驱动与 `smoltcp` 结合的方案

定义好 `net_stack` 异步函数，在其中调用同步的 `iface_poll` 函数，每次 `iface_poll` 函数结束，当网卡的缓冲区中没有数据时，这个函数会返回 `false`。此时，`net_stack` 这个函数应该返回 `pending`，在返回之前，我们可以拿到对应的 `cx`，向 `ATSINTC` 中注册中断处理协程，返回 `pending` 后将 CPU 让给其他任务执行。

这是对于驱动与协议栈结合的部分。

#### 协议栈与上层的应用结合的方案

这里的上层应用是指那些需要操作 Socket 的异步函数，这里可以直接利用 `smoltcp` 提供的 `async` feature。这样绕过了中间同步的协议栈部分。

### 怎么进行对比测试

如果上述方案没有出现问题，那么可以对比的有三项：`smoltcp + poll`、`smoltcp + intr` 和 `smoltcp + atsintc`（`embassy-net` 中的对比可以暂时先不管了）。

