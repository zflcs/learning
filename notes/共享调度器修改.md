##### 王文智共享调度器目前存在的问题

- 首先是关于进程、线程、协程，此时TCB还是表示的进程，协程是在线程测试时直接添加到EXECUTOR中
- 虽然协程支持优先级，但是对于TCB优先级的调整prioritize并未进行调用，主要是目前只支持一个线程，因此并没有体现出来好处
- 系统调用的实现，实际上还是同步的过程
- 对于用户态使用创建协程的接口，调度器会被编译成elf可执行文件，同时映射在了内核和用户空间中，内核和用户通过jp addr形式调用其中函数，这个过程比较复杂
- 内核和用户进程不是共享同一个EXECUTOR
- 读取符号表每次都需要打开文件





##### 王文智共享调度器的使用流程

##### 内核态初始化过程

- 初始化其他模块之后，会执行init_cpu_test函数，创建回调队列、调度器、添加idle_main以及thread_main_ex线程，之后通过run_tasks函数会先执行idle_main线程
- idle_main线程首先会从线程池中获取可运行的线程（实际上就是thread_main_ex线程），之后切换线程，若没有可执行的线程，则会从EXECUTOR中寻找协程，若找到了协程，则会创建一个新的线程来执行协程
- 若从idle_main线程切换到thread_main_ex线程，则会从EXECUTOR中获取到一个协程来执行，如果没有协程则会陷入到死循环，直至添加进入了新的协程

##### 用户态

- 在用户态的 lib.rs 的 _start() 函数直接初始化协程使用环境，后续的 main 函数就可以直接使用相关的接口：__start() 调用 init_environment() 函数


- init_environment() 函数初始化使用的堆之后，调用 init_cpu_test() 函数，初始化 cpu 调度器、线程池、idle_main 线程、thread_main_ex 线程
- 初始化协程使用的接口之后，就开始执行 main 函数，main 函数起始会执行依次系统调用获取时间，之后开始执行 test_for_user 的测试代码，执行测试代码之后再获取一次时间，来获得总体的运行时间
- 在 test_for_user 函数中使用 async 关键字创建协程，调用 add_coroutine_with_prio 将协程添加到 executor 中，然后开始执行 cpu_run 运行协程
- cpu_run 运行协程

    - 一次性添加完所有协程之后，再通过coroutine_run开始进行调度，主要是开始执行thread_main_ex线程
    - thread_main_ex线程，会从cbq中取出cids，然后全部唤醒，并找到tid、task、waker等信息
    - 之后根据waker创建上下文，之后通过poll来推进，如果协程已经执行完，那么就会从EXECUTOR中删除
    
    - 若EXECUTOR中没有协程，则会退出thread_main_ex线程，回到idle_main线程，在测试的代码中是直接通过函数调用的方式，而不是真正的线程切换

*上述的部分已经可以运行简单的 demo，还需要对优先级的部分进行更改*

##### 协程支持优先级

- 通过bitmap来管理优先级，总共PRIO_NUM个优先级，每个优先级对应着一个协程队列，添加协程时会指定所属的优先级
- 对用户bitmap的更新主要是通过设置对应的优先级，而不是对每个优先级队列的顺序进行更新
- 对内核的位图进行更新时，依次获取用户位图（最多允许MAX_USER个用户位图）并进行或操作，之后获取到最高优先级的线程插入到PRIO_PIDS中来进行管理
- 之后进行线程调度时，会先从PRIO_PIDS中进程的PID，若没有，则是直接弹出就绪队列的头部，若是PRIO_PIDS中取出了pid，则从就绪线程队列中找到对应pid的线程来执行
- 通过prioritize函数对线程池中的线程进行排序



##### bitmap 的实现细节

- bitmap 只有 8 位，设置的却是 usize，每一个位表示一个队列，因此只有 8 个队列
- 两个位图，sys_bitmap 和 user_bitmap



##### 从王文智处继承共享调度器的代码

- _start() 函数直接调用 init_environment() 函数初始化堆
- init_environment() 函数中直接调用 init_cpu_test() 函数





##### 共享调度器修改

- [x] VDSO 加载 demo 运行

- [ ] 将 CBQ 修改为共享调度器中的堆中指定的内存区域，而不是直接操作原始指针

    带来的问题：CBQ 的容量受到限制（4000 + 5 -> 400 + 5，定义最多 16 个进程），如果要增大容量，则需要对 heap 的容量进行修改，然后这又会导致 easy-fs-use 创建 basic_rt 文件时，会使得编译出的文件大小超过一个 inode 表示的最大大小

- [ ] 将 bitmap 修改为共享调度器的堆中的内存区域

