##### 王文智共享调度器目前存在的问题

- 首先是关于进程、线程、协程，此时TCB还是表示的进程，协程是在线程测试时直接添加到EXECUTOR中
- 虽然协程支持优先级，但是对于TCB优先级的调整prioritize并未进行调用，主要是目前只支持一个线程，因此并没有体现出来好处
- 系统调用的实现，实际上还是同步的过程
- 对于用户态使用创建协程的接口，调度器会被编译成elf可执行文件，同时映射在了内核和用户空间中，内核和用户通过jp addr形式调用其中函数，这个过程比较复杂
- 内核和用户进程不是共享同一个EXECUTOR
- 读取符号表每次都需要打开文件





##### 王文智共享调度器的使用流程

##### 内核态初始化过程

- 初始化其他模块之后，会执行init_cpu_test函数，创建回调队列、调度器、添加idle_main以及thread_main_ex线程，之后通过run_tasks函数会先执行 thread_main_ex 线程，进入 loop 循环
- idle_main线程首先会从线程池中获取可运行的线程（实际上就是thread_main_ex线程），之后切换线程，若没有可执行的线程，则会从EXECUTOR中寻找协程，若找到了协程，则会创建一个新的线程来执行协程
- 若从idle_main线程切换到thread_main_ex线程，则会从EXECUTOR中获取到一个协程来执行，如果没有协程则会陷入到死循环，直至添加进入了新的协程

##### 用户态

- 在用户态的 lib.rs 的 _start() 函数直接初始化协程使用环境，后续的 main 函数就可以直接使用相关的接口：__start() 调用 init_environment() 函数


- init_environment() 函数初始化使用的堆之后，调用 init_cpu_test() 函数，初始化 cpu 调度器、线程池、idle_main 线程、thread_main_ex 线程
- 初始化协程使用的接口之后，就开始执行 main 函数，main 函数起始会执行依次系统调用获取时间，之后开始执行 test_for_user 的测试代码，执行测试代码之后再获取一次时间，来获得总体的运行时间
- 在 test_for_user 函数中使用 async 关键字创建协程，调用 add_coroutine_with_prio 将协程添加到 executor 中，然后开始执行 cpu_run 运行协程
- cpu_run 运行协程

    - 一次性添加完所有协程之后，再通过coroutine_run开始进行调度，主要是开始执行thread_main_ex线程
    - thread_main_ex线程，会从cbq中取出cids，然后全部唤醒，并找到tid、task、waker等信息
    - 之后根据waker创建上下文，之后通过poll来推进，如果协程已经执行完，那么就会从EXECUTOR中删除
    
    - 若EXECUTOR中没有协程，则会退出thread_main_ex线程，回到idle_main线程，在测试的代码中是直接通过函数调用的方式，而不是真正的线程切换

*上述的部分已经可以运行简单的 demo，还需要对优先级的部分进行更改*

##### 协程支持优先级

- 通过bitmap来管理优先级，总共PRIO_NUM个优先级，每个优先级对应着一个协程队列，添加协程时会指定所属的优先级
- 对用户bitmap的更新主要是通过设置对应的优先级，而不是对每个优先级队列的顺序进行更新
- 对内核的位图进行更新时，依次获取用户位图（最多允许MAX_USER个用户位图）并进行或操作，之后获取到最高优先级的线程插入到PRIO_PIDS中来进行管理
- 之后进行线程调度时，会先从PRIO_PIDS中进程的PID，若没有，则是直接弹出就绪队列的头部，若是PRIO_PIDS中取出了pid，则从就绪线程队列中找到对应pid的线程来执行
- 通过prioritize函数对线程池中的线程进行排序



##### bitmap 的实现细节

- bitmap 只有 8 位，设置的却是 usize，每一个位表示一个队列，因此只有 8 个队列
- 两个位图，sys_bitmap 和 user_bitmap



##### 从王文智处继承共享调度器的代码

- _start() 函数直接调用 init_environment() 函数初始化堆
- init_environment() 函数中直接调用 init_cpu_test() 函数







### 总体设计

**linux o(1) 算法**：

- 位图支持 8 个优先级；内核一个位图，每个用户进程各自拥有一个位图，用户进程数最大限制为 14；
- 内核以及用户进程访问系统位图是通过 SYS_BITMAP_VA = 0x87412000 来直接访问
- 内核通过 USER_BITMAP_BASE_PA + PAGE_SIZE * i 来访问各个进程的位图；进程只能通过 USER_BITMAP_VA 来访问自己的位图
- 回调队列的设计以及访问与位图相似







##### 共享调度器修改

- ~~VDSO 加载 demo 运行~~

- 将 CBQ、bitmap 修改为共享调度器中的堆中指定的内存区域，而不是直接操作原始指针

    - CBQ 的容量受到限制（4000 + 5 -> 400 + 5，定义最多 16 个进程），如果要增大容量，则需要对 heap 的容量进行修改，然后这又会导致 easy-fs-use 创建 basic_rt 文件时，会使得编译出的文件大小超过一个 inode 表示的最大大小

    - 所有的 CBQ 以及 bitmap 都在共享库中，在进程更新位图时，首先是需要知道自己的 pid，其次是不安全，当前的进程可以更改其他的进程的位图

- ~~还是按照原来的做法，直接建立地址映射~~

- 测试共享调度器的接口在 VDSO 模式下能否正常使用

    - ~~首先设计好查询符号表的接口，将共享调度器的接口暴露给用户进程，还是像之前那样一次系统调用只查询一个接口~~
    - ~~尝试添加带有优先级的用户协程，先添加简单的测试协程，并且测试协程运行接口~~
    - ~~尝试增加异步系统调用 async_sys_write 和 async_sys_read，需要增加支持 6 个参数的系统调用接口，目前 6 个参数的系统调用仅仅是异步读写，因此进入内核之后，可以根据 syscall_id 的大小来判断是对一个哪一个接口（大于 1500 就会跳转到 支持 6 个参数的系统调用）~~
    - ~~创建服务端与用户端的协程，创建 AsyncCall 数据结构，并实现 Future 特性~~
    - 在内核添加 async_sys_read 以及 async_sys_write 的实现，
        - ~~async_sys_write 会直接调用 sys_write 写入文件，然后写完了之后，则会唤醒对应的 读协程~~
        - ~~唤醒读协程的操作是通过一个 WRMAP 的 BTreeMap 来建立的，这个是在内核的代码中的，共享库中没有~~
        - async_sys_read 先找到对应的文件描述符，然后创建 aread 协程并且添加到对应的优先级队列中
        - aread 异步系统调用会创建协程，但是不同的文件类型对于 aread 的实现不同，inode 中的 aread 实现只需要将文件访问的过程用 async 封装即可，然而 pipe 中的 aread 实现则需要对



#### 内核与用户态协程优先级交错实验

将内核创建协程的过程也看作一个普通的用户线程一般，创建一个 GLOBAL_BITMAP，对 GLOBAL_BITMAP 更新时，如果内核协程的优先级不高，用户协程的优先级更高，则在 GLOBAL_BITMAP 中调度时，就会先去执行用户协程，但是还只是想法，具体的代码没有写





#### 建议

把 print 相关的代码独立成一个 crate 库



