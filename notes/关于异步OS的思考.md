### 关于异步OS的一些思考：

1. 最小的调度单位是协程：显然这是没有问题的

2. 进程、线程、协程并存：这仍然是可以的

3. 线程与协程相结合：一个线程中包含多个协程，在我看来是这个意思：一个线程有一个 executor，然后有若干个协程（future），在协程执行时，实际上就是在执行一段函数；协程执行完毕，由 executor 来调度，这个时候，如果所有的协程全部都被阻塞时，executor 在调度协程时，会检查是否出现这种情况，然后会将所属的线程阻塞，这个时候就可以调度其他的线程来执行

4. 在什么情况下会发生协程在多个线程之间调度？？？

    如果当前的线程在执行某个协程，但是并没有完成，此时不能把栈清空给下一个协程来使用，这个时候又来了另一个中断，例如该线程内的另一个协程等待的 IO 事件已经处理完毕，发出了中断请求，这时候就应该把对应的协程从线程中取出来，然后调取其他的线程来执行这个协程

5. 协程在多个线程之间调度：每个线程的 executor 都有一个协程队列，因此协程可以在线程内部进行调度，如果协程要能够在线程之间进行调度，那么则至少需要在进程或者内核当中构建一个管理者 FUTURE_MANAGER，从而使得能够在线程之间进行调度，协程在多个进程之间调度同样也是如此，虽然这样看上去简单明了，但是里面的细节还需要推敲

    1. 首先当前的线程正在执行的协程还没有结束，在执行完一条指令之后，另一个协程等待的事件完成，产生了中断，这个时候控制权到了内核，内核会进入到相应的中断处理函数

    2. 在中断处理函数中，需要完成的两件事情，**首先面临的问题是找到对应的协程**。例如从 stdin 读取字符，通常情况下，我们是通过线程主动发起系统调用，最终通过一个 loop 循环来等待输入字符，这个过程是同步的，因此可以直接找到对应的线程，在王文智学长的代码中，这部分是通过一个 BTreeMap 来维护读协程 id 与写协程 id 的对应关系，因此可以通过写协程来唤醒读协程，这只是一个特例，暂时跳过，就以学长的代码为例子，梳理一下整个思路

    3. 找到了对应的协程之后，首先判断正在执行的协程的状态，如果已经执行完毕，则直接调度不用切换线程；如果当前协程还没执行完毕，必须要找到另一个支持协程的线程来运行目标协程，这时候需要线程切换。王文智学长通过上述建立的对应关系，当异步写系统调用（实际上仍然是同步的过程）完成时，会唤醒对应的写协程，并更新对应的 user_bitmap，之后线程会返回到用户态，然后所属的协程执行完毕，剩下的过程就交给 EXECUTOR 调度器来调度即可

    4. 是实现一个全局的调度器还是在每个线程内部都存在一个调度器

        学长的实现方式：无论是内核还是用户态的协程都是添加在一个统一的 EXECUTOR 中，然后在此基础上来调度，所以这里也带来了一个新的问题， basic_rt 模块需要从文件系统中加载进入内核（我觉得直接在创建线程的时候就可以建立这块共享区域的地址映射，这样子应该会简单一点）；但是在我看来，应该每个线程包括一个 executor 调度器，在这个基础上来实现的话，就可以在创建线程时就将 executor、waker 等数据结构添加进线程中，但是这样子是不是会带来新的问题呢？例如切换上下文是否会增加开销？？？

    5. 关于学长代码中的线程与我想的线程

        学长的线程与正常的线程相同，只不过会在主函数中有所区别，支持协程的线程会在主函数中会绑定 EXECUTOR 来调度，正常的线程主函数则没什么区别；然而在我看来，线程应该分为两类，一类是正常的线程，另一类则是支持协程的线程，这类线程内部需要包含 executor、waker 等数据结构

    6. 关于用户态怎么能够感知到自己的 executor？？？

        一种方法就是新建一个系统调用，但是这样在用户态的协程调度又会进入到内核态，这个时候效率又会降低；

        另一种方式还是通过系统调用，直接得到对应的协程接口在线程的虚拟地址，也就是和学长的方法类似，之后就可以在主函数中创建、添加、调度协程，从而不用进入内核态，只需要在一开始执行一次系统调用即可

    7. 关于协程在不同的线程之间的调度，暂时没有什么头绪，或许可以从一些自然界中种群的分工合作现象得到答案

    8. 关于学长 EXECUTOR 全局调度器的调度策略？？？

        有一个全局的线程池 TASK_POOL，内部封装了一个 scheduler 调度器以及一个阻塞的线程集合 BTreeSet，scheduler 中维护了一个就绪线程队列，之后对线程的调度则是通过 TASK_POOL 来进行，包括更改任务的优先级；

        在 EXCUTOR 协程调度器中，封装了协程队列 task_queue、waker_cache，对于调度，只需要在 waker _cache 中唤醒协程即可，这些操作全部都是对于 tid 来进行的，因此进行优先级更新时，是对 tid 来进行的？？？
    
    9. 关于学长异步系统调用的问题：
    
        虽然是异步读写的名称，但是实际上还是在同步的等待这个过程，我理解的是不能读或者写的时候，直接会返回到用户态，然后阻塞当前的协程，这是需要改进的地方





内核切换到用户进程，用协程来写，这样自然就转换成所有的协程模型