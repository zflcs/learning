### 进程、线程、协程

#### 进程：

资源分配的单位

#### 轻权进程：

实际就是内核支持的线程，和其他的进程共享资源

#### 内核支持的线程：

CPU 与线程的绑定

#### 用户态的线程：

与内核线程的区别在于进入内核时，其他的用户态线程会阻塞，而内核支持的线程则不会。

#### 协程：

任务的实体，CPU 调度的对象。



#### 为什么会有用户态线程和内核支持的线程的讨论？

**事情的起因：**本来想的是创建了一个进程，进程的入口是共享调度器，之后在用户态创建用户线程，由用户态的线程来执行协程，共享调度器的代码再根据负载来创建线程执行，这种情况创建的线程，CPU 感知不到，还是一个 CPU 在执行；当需要多个 CPU 来执行同一个进程内的不同线程时，基于目前的框架，我认为是只能创建多个内核支持的线程（实际上是多个上下文），这样才能让多个 CPU 执行同一个进程。

**周五讨论的结论：**从协程的视角来看，内核支持的线程和用户态的线程没有区别，只是提供了一个栈；

从 CPU 的角度来看：内核支持的线程，CPU 可以感知到，因此可以调度；用户态的线程，只能依附到内核支持的线程，CPU 感知不到。



实际上，用户线程在这里没有什么用，至少没有想到有什么场景会用到，只是不会进到内核去创建；这里完全可以用 sys_thread_create 系统调用创建内核支持的线程来执行协程，一个线程的栈被抢占了，其他的线程还是可以执行其他的协程，这是完全没有问题的。但是系统调用进到内核会有开销，要减少这个开销，只能是用户进程进入到共享代码的部分，创建的线程，能够让 CPU 感知到，能够调度。





