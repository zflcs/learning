### 进程、线程、协程

#### 进程：

资源分配的单位

#### 轻权进程：

实际就是内核支持的线程，和其他的进程共享资源

#### 内核支持的线程：

CPU 与线程的绑定

#### 用户态的线程：

与内核线程的区别在于进入内核时，其他的用户态线程会阻塞，而内核支持的线程则不会。

#### 协程：

任务的实体，CPU 调度的对象。

| 概念 | 定位                                                   |
| ---- | ------------------------------------------------------ |
| 进程 | 地址空间隔离，资源分配的单位（主要是文件、锁、信号等） |
| 线程 | 提供 CPU 执行的上下文信息，给协程提供栈                |
| 协程 | 任务的实体                                             |



#### 为什么会有用户态线程和内核支持的线程的讨论？

**事情的起因：**本来想的是创建了一个进程，进程的入口是共享调度器，之后在用户态创建用户线程，由用户态的线程来执行协程，共享调度器的代码再根据负载来创建线程执行，这种情况创建的线程，CPU 感知不到，还是一个 CPU 在执行；当需要多个 CPU 来执行同一个进程内的不同线程时，我认为是只能创建多个内核支持的线程（实际上是多个上下文），这样才能让多个 CPU 执行同一个进程。

**周五讨论的结论：**从协程的视角来看，内核支持的线程和用户态的线程没有区别，只是提供了一个栈；

从 CPU 的角度来看：CPU 执行，必须要有栈，这个角度看都是相同的，但是内核支持的线程，CPU 可以感知到，因此可以调度；用户态的线程，只能依附到内核支持的线程，CPU 感知不到。

在上面的描述下，用户线程在这里没有什么用，至少没有想到有什么场景会用到，只是不会进到内核去创建；这里完全可以用 sys_thread_create 系统调用创建内核支持的线程来执行协程，一个线程的栈被抢占了，其他的线程还是可以执行其他的协程，这是完全没有问题的。但是系统调用进到内核会有开销，要减少这个开销，只能是用户进程进入到共享代码的部分，创建的线程，能够让 CPU 感知到，能够调度。

要解决的问题：进入到用户态创建的线程怎么样能够被调度

1. fast-trap 提供的系统调用，创建内核支持的线程，可行，创建线程不需要切换地址空间，因此只需要保存一部分寄存器
2. 一个全局的队列，所有的进程都可见，在共享代码中，可以创建线程让 CPU 调度（飓风内核），这种情况下不区分内核支持的线程和用户态线程
3. 进程 PCB 中的线程队列建立地址映射，在进入用户态也可以访问，可以插入和删除，内核的调度方式进行调整





