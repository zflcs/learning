#### shell 响应慢
初步怀疑和内核目前的调度方式相关，内核的调度以协程的形式来完成，因此在切换回原来的形式（初始化之后运行调度函数，只有核 0 处理内核协程）之后，shell 的响应速度正常。

将内核的调度实现为协程之后，内核初始化完成之后，处于 idle 线程（没有显式的初始化创建线程操作）内，执行循环 poll 内核协程的函数（poll_kernel_future），与用户线程相同，但内核线程的状态转换与用户线程的状态转换存在区别。

##### 目前调度协程的实现
```rust
pub async fn run_tasks() {
    let mut helper = Box::new(ReadHelper::new());
    loop {
        if let Some(task) = fetch_task() {
            PROCESSORS[hart_id()].run_next(task);
            PROCESSORS[hart_id()].suspend_current();
        }
		helper.as_mut().await;
    }
}
```
无论能否从线程池取出协程，都会对 helper 进行 poll，这导致了大量的协程切换开销。假设在执行某个线程之后，它会向内核提交某些内核协程，这些协程的优先级比调度协程的优先级高，因此在发生时钟中断回到 idle 线程时，内核的调度协程需要让权。基于上述的假设，将 await 放在 if 语句内，减少协程切换开销。
```rust
pub async fn run_tasks() {
    let mut helper = Box::new(ReadHelper::new());
    loop {
        if let Some(task) = fetch_task() {
            PROCESSORS[hart_id()].run_next(task);
            PROCESSORS[hart_id()].suspend_current();
			helper.as_mut().await;
        }
    }
}
```

移动到 if 语句内，仍然不能即使响应，在将切换的频率降低之后，得到了正常响应。

#### 0x101000000 页错误

把 MEMORY_END 扩大之后，遇到了 0x101000000 页错误，还不清楚是什么原因

#### 创建进程时，查找符号表慢（暂时不考虑）



#### async_pipe_multi_ring
##### 4+128+1：
5321


##### 协程 50 + 1 + 20：
28709、28713、28219、28250、28081、28679、29071、27778、29672、29625

##### 协程 50 + 2 + 20：
32835、33062、33291、31886、33922、32637、33675、32905、32388、32642

##### 协程 50 + 4 + 20：
43172、42818、46263、41324、41448、45223、42021、44713、42786、43299

##### 协程 50 + 8 + 20：
62008、64926、73583、51020、78256、52302、63805、68604、70165、59937

##### 协程 50 + 16 + 20：
38127、39866、38954、41001、40924、45048、40691、43185、42311、39012

##### 协程 50 + 32 + 20：
57698、59243、57664、58667、61436、85798、55573、55929、54140、61677

##### 协程 50 + 64 + 20：
120884、134359、112551、



#### 串口输出问题，输出不了 total time
- 可能是代码存在的 bug，在 qemu 中体现不出来