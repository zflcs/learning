## 任务设计

进程和线程不做区分，内核的调度队列中不区分线程和协程，都在同一个队列中进行调度

## 陷入设计

- 上下文保存在控制流所对应的栈的顶部

- 上下文的结构如下，主要是 sp 需要保存在栈顶

  ```rust
  #[repr(C)]
  #[allow(missing_docs)]
  pub struct FlowContext {
      pub t: [usize; 7],  // 0..
      pub a: [usize; 8],  // 7..
      pub s: [usize; 12], // 15..
      pub gp: usize,      // 27..
      pub tp: usize,      // 28..
      pub pc: usize,      // 29..
      pub ra: usize,      // 30..
      pub sp: usize,      // 31，
  }
  ```

  基于上述两点，可以把用户和内核栈映射到固定的虚拟地址，在进入到 stvec 寄存器指向的 fast-handler 函数时，保存上下文到用户态栈顶的上下文中

  - 这个过程不需要切换 sp 寄存器中的值，sscratch 寄存器可以用于存放其他有用的信息
  - fast-handler 直接复用用户态的栈
  - 注意：需要特别处理恶意用户程序，写了不能访问的 sp，在进入到 s 态之后会触发 s 态的异常，这属于缺页异常，但是需要直接杀死这个恶意进程；同时，返回用户态时，需要对栈下面的数据擦除（是否擦除还需要考虑）

  按照这种方式，所有的控制流只会有一个栈，同时也可以实现内核快速路径（内核快速路径可能需要和 vdso 结合起来）
  内核应该当作一个进程，循环处理中断和异常

## 地址空间切换

地址空间切换和陷入密切相关

fast-handler 函数：发生中断/异常后，跳转到这里，接下来保存一部分寄存器，match 语句处理完部分的异常或中断，（这个阶段还是在用户进程地址空间），根据返回的结果，若处理完成，则返回用户态；若不能处理的中断/异常，则进行进程切换，切换到内核进程，需要切换地址空间和恢复内核上下文。

若需要进程切换，则需要把剩下的寄存器保存完。这时整体的上下文保存结束，之后切换地址空间，由于上下文都被保存在各自的栈中，因此需要先切换地址空间，才可以恢复内核进程的上下文。内核的地址空间不能是固定的，因此可以将内核地址空间事先保存在 sscratch 寄存器中，之后再从指定的栈的虚拟地址读出上下文，从而切换到内核进程。

从 s 态进入到 u 态时，无论是从快速路径返回到用户态的，还是直接从内核进程切换到用户进程，这部分代码都需要保存在公共地址空间。进程切换函数的参数为 satp，satp 寄存器不需要保存在上下文中，而是保存在进程控制块中，这样不需要额外进行地址转换。



## 用过程宏实现系统调用

具体使用派生宏，为枚举类型生成每个系统调用，并且可以指定参数类型

```rust
#[repr(usize)]
#[derive(Debug)]
pub enum SyscallId{
    #[syscall_arg(args = "arg1_name: arg1_type, arg2_name: arg2_type")]
	read = 4,
    write = 5,
}
```



## 实现过程中遇到的问题

### riscv 寻址模式：

> 立即数寻址
>
> 寄存器寻址
>
> 基址寻址：寄存器的偏移用立即数表示，但是只能是 12位
>
> pc 寻址

没有直接寻址模式，如果直接对固定的栈顶位置进行内存操作，如果是 x86 则可以直接寻址，因此这个栈的地址可以是任意的，但是 riscv 没有直接寻址，并且这种设计思路不能使用 sscratch 寄存器，因此把 立即数寻址、寄存器寻址、pc 寻址全部排除，只剩下基址寻址，并且基址寻址只能使用 x0 寄存器，那么可以考虑使用有符号的立即数，0x0 - 1 = 0xffffffffffffffff，通过这种方式进行寻址，因此直接限制了栈顶的虚拟地址为 0xffffffffffffffff

### 栈高位虚拟地址映射

栈映射到高位的虚拟地址，这里需要特别处理，先建立对等映射和高位虚拟地址映射，之后将 sp 寄存器赋值为高位的虚拟地址，再取消掉对等映射

### 把内核当作进程

如果把内核当作完全对等的用户进程，那么在进入到内核进程时，还需要保存一轮寄存器信息，这个开销也是很大

经过测试，在内核中，直接用汇编代码，重新设置 sp，跳转到内核进程的代码，这种方式是正常的。因此只需要在栈顶上设置了 sp 和 ra，那么内核的上下文就不需要保存了，每次陷入，直接从对应的地址中读出这两个信息，跳转进入到内核进程

### 用户进程没有内核栈

在内核中的自旋等行为不能实现

### 栈映射到固定虚拟地址，多线程情况下地址空间如何处理

类似 linux，不对线程和进程做区分，看作是共享某些资源的进程

