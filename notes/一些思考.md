## 任务设计
进程和线程不做区分，内核的调度队列中不区分线程和协程，都在同一个队列中进行调度

## 陷入设计
- 上下文保存在控制流所对应的栈的顶部
- 上下文的结构如下，主要是 sp 需要保存在栈顶
    ```rust
    #[repr(C)]
    #[allow(missing_docs)]
    pub struct FlowContext {
        pub sp: usize,      // 0.. 
        pub satp: usize,    // 32..
        pub ra: usize,      // 0..
        pub t: [usize; 7],  // 1..
        pub a: [usize; 8],  // 8..
        pub s: [usize; 12], // 16..
        pub gp: usize,      // 28..
        pub tp: usize,      // 29..
        pub pc: usize,      // 31..
    }
    ```
    基于上述两点，可以把用户和内核栈映射到固定的虚拟地址，在进入到 stvec 寄存器指向的 fast-handler 函数时，保存上下文到用户态栈顶的上下文中
    - 这个过程不需要切换 sp 寄存器中的值，sscratch 寄存器可以用于存放其他有用的信息
    - fast-handler 直接复用用户态的栈
    - 注意：需要特别处理恶意用户程序，写了不能访问的 sp，在进入到 s 态之后会触发 s 态的异常，这属于缺页异常，但是需要直接杀死这个恶意进程；同时，返回用户态时，需要对栈下面的数据擦除（是否擦除还需要考虑）

    按照这种方式，所有的控制流只会有一个栈，同时也可以实现内核快速路径（内核快速路径可能需要和 vdso 结合起来）
    内核应该当作一个进程，循环处理中断和异常