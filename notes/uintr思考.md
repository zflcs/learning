#### 用户态中断 uintr



##### 多线程情况下的使用：

发送方多线程，每个线程没有单独注册发送方，那么在发送中断时，会出现中断丢失的情况，多核情况下，响应第一个中断进入用户态中断处理函数读取 irq 时，另一个线程也进行了修改，这时会把上一个中断丢失掉。如果利用 irq 编号传递信息时，则会导致一些问题。因此，目前的 uintr 还是只能用来通知，不能用来传递信息。需要与内存配合进行使用。

如果要在多线程的情况下使用，中断信号分发到具体的线程还需要具体商榷。当接收方存在多线程，多个线程同时进入用户态中断处理函数，那么用于缓存信息的内存区域还需要保证同步互斥。





不同情形下，uintr 使用的使用需要规范。





##### 进入 s 态和退出 s 态时，u csr 寄存器的处理流程

ustatus 作为 sstatus 的寄存器的子集，sideleg 用于将哪些中断委托给用户态进行处理

进入 s 态：sstatus 寄存器的 sie 被清零，因此无论 ustatus 的寄存器是什么状态，都不会响应用户态中断，因此在返回 u 态时，需要将 sideleg 打开 usoft，sip 中设置 usoft，这样才有可能进入到用户态的中断处理函数中，但是不能一定进入，还取决于 ustatus 寄存器

在 s 态中，不需要操作 ustatus 寄存器的状态，只需处理 sideleg 和 sip 的寄存器，在返回时，根据当前进程 task 内的 uintr 相关的数据结构设置 sideleg 和 sip 寄存器的相应位置，ustatus 寄存器的状态只在 u 态进行修改，并且在进入内核和返回用户态时，手动保存



目前没有保存 ustatus 寄存器，并且在内核操作了 ustatus 寄存器，一旦有用户态中断，一股脑把 ustatus 的 uie 使能，uie 设置了 usoft，因此会产生重复进入中断处理函数，无法返回正常执行流的情况。在多个发送方的场景下，接收方进入到第一个中断处理函数中，这时 ustatus 的 uie 被清零，upie 被设置为使能，这时通过系统调用进入到内核中，另一个发送方向该进程发送了第二个用户态中断，因此返回时，所有的 csr 寄存器都被设置，满足进入用户态中断的条件，进程会进入到第二个用户态中断中，原来正常执行流的 uepc 已经丢失，已经丢失，因此用户态中断上下文保存与恢复时需要将 uepc 保存起来。将 uepc 保存起来后，尽管可以恢复，但是还是遇到了一些奇怪的问题，卡死，这种中断嵌套应该不被允许。

一旦进程正在用户态中断处理函数中，ustatus 寄存器的 uie 会被清空，upie 设置为之前的状态（使能），通过系统调用或者时钟中断进入到内核上下文保存时，将 ustatus 寄存器保存起来，这样，即使在内核中有其他发送方发送了用户态中断，进程在返回时，恢复上下文时，ustatus 寄存器仍然会恢复成第一个中断处理时的寄存器状态（ustatus uie 位被清空），因此不会进入到第二个中断处理函数，杜绝了中断嵌套。返回时还是返回到正常的执行流。



在中断处理函数中 upie 为 1，uie 为 0，还需要在 sret 之前关闭中断



**关键点：ustatus 寄存器与 sstatus 寄存器相同，也属于这个进程，所以需要在上下文中进行保存**







也许可能一次丢了多个中断，但最终会响应一个中断，



