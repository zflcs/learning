### 设计方案

#### 内核中的设计：

##### 优先级

- Task 增加优先级字段，每次陷入内核时，更新当前 Task 对应的进程组的所有 Task 的优先级，如果其中某个 Task 正在运行，则不这个 Task 更新。
- 内核中增加共享调度器的数据结构，保存函数指针，两个就绪队列，一个是所有进程的优先级队列，另一个是内核中所有协程的优先级队列。在其中维护全局优先级位图，并共享只读权限给所有 Task
- 全局位图数据结构
    


##### Executor 设计

- 改成无锁队列，不需要优先级位图，只维护最高优先级字段
    - MPMC + AtomicUsize 实现带有 is_empty 的无锁队列，尽管中间的操作时分离的，但是不会影响正确性
- 最高优先级字段的维护
    - 添加新协程时，目标优先级队列如果为空，且比当前优先级高，则更新
    - 取出协程不进行更新，协程执行结束后判断进行更新
    - 删除协程时，不需要对更新，因为在协程执行结束之后就会更新
- 不再使用 map，直接在队列中保存 CCB 数据结构



##### 概念上的思考

1. 系统中的任意一块代码，所属的对象？
2. 状态图中有栈和无栈的情况？被中断或异常打断的情况，协程的状态应该怎么变换？
3. 流程图的切换，内核中怎么维护优先级？不需要主动的扫描最高优先级，在添加到就绪队列时，根据优先级字段即可。



##### 代码实现上的思考

1. 目前 Future 实现并没有返回值，按照惯例，每个任务都应该有一个返回值的字段，用于表示任务完成得情况，后续得代码改进，可以从这里入手。

    





##### 新的角度

共享调度器可以管理的协程，是由语言、编译器和操作系统等软件层面上进行控制的软件协程，这一类协程是在 Rust 语言的基础上提供的无栈协程，编译器帮助实现了上下文切换。

而系统中还存在着另一类协程，由硬件机制提供的硬件协程（尽管现在称之为线程），这类协程的上下文切换主要是操作系统提供（即跳板页代码以及用户态中断的上下文切换代码），而它的优先级则是由硬件来控制，其优先级凌驾于所有的软件协程之上，一旦硬件发出信号，其他软件协程只能无条件让权。

根据这种视角，可以把中断、异常、系统调用这几种需要硬件机制参与的过程也归结于硬件协程，从而使得跳板页代码和上下文切换的汇编代码归属于协程，并且也可以满足协程的主动切换的特性，从而能够解释这些处于特殊区域的代码。在内核中的其他代码附属于这些硬件协程或者属于软件协程。

共享调度器作为操作系统内核一个模块，它只能管理软件上的协程，对于硬件上的协程，只能配合其行为，充当硬件协程和软件协程的连接点。

