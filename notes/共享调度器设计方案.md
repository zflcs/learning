### 设计方案

#### 内核中的设计：

##### 优先级

- Task 增加优先级字段，每次陷入内核时，更新当前 Task 对应的进程组的所有 Task 的优先级，如果其中某个 Task 正在运行，则不这个 Task 更新。
- 内核中增加共享调度器的数据结构，保存函数指针，两个就绪队列，一个是所有进程的优先级队列，另一个是内核中所有协程的优先级队列。在其中维护全局优先级位图，并共享只读权限给所有 Task
- 全局位图数据结构
  


##### Executor 设计

- 改成无锁队列，不需要优先级位图，只维护最高优先级字段
    - MPMC + AtomicUsize 实现带有 is_empty 的无锁队列，尽管中间的操作时分离的，但是不会影响正确性
- 最高优先级字段的维护
    - 添加新协程时，目标优先级队列如果为空，且比当前优先级高，则更新
    - 取出协程不进行更新，协程执行结束后判断进行更新
    - 删除协程时，不需要对更新，因为在协程执行结束之后就会更新
- 不再使用 map，直接在队列中保存 CCB 数据结构



##### 概念上的思考

1. 系统中的任意一块代码，所属的对象？
2. 状态图中有栈和无栈的情况？被中断或异常打断的情况，协程的状态应该怎么变换？
3. 流程图的切换，内核中怎么维护优先级？不需要主动的扫描最高优先级，在添加到就绪队列时，根据优先级字段即可。

- 中断与异常，在内核被异常打断，处理异常的例程算到什么状态，把中断处理历程函数，在用户态的状态与在内核态的状态中断处理的异常
- 中断与异常也按照异步系统调用的处理，进到内核之后，创建协程，返回用户态，继续执行其他的协程，栈与 CPU 两种资源的占用进行划分
- 系统调用已经改造成异步的，所以能够符合异步操作系统的状态图，但是中断和异常没有按照异步的处理，所以在这里不太符合异步操作系统的特征。
- 内核系统调用分发的协程，用户态发中断指令，改造空间 ecall 不陷入内核，发出中断给其他核的内核，用户进程给内核发中断
- 进出内核的代码归属于哪个协程，内核的操作算一个协程
- 同步和异步接口，通过链接的形式进行



##### 代码实现上的思考

1. 目前 Future 实现并没有返回值，按照惯例，每个任务都应该有一个返回值的字段，用于表示任务完成得情况，后续的代码改进，可以从这里入手。

2. 使用新的用户态中断后，怎么唤醒协程？

    1. 可以使用 irq 来传递协程 id，但这又需要增加系统调用的参数

    

1. 其他核已经处理好了网卡，向 socket 缓冲区中准备好了数据，这时再进行 aread，应该是可以直接执行的，不需要等待

 

##### 新的角度

共享调度器可以管理的协程，是由语言、编译器和操作系统等软件层面上进行控制的软件协程，这一类协程是在 Rust 语言的基础上提供的无栈协程，编译器帮助实现了上下文切换。

而系统中还存在着另一类协程，由硬件机制提供的硬件协程（尽管现在称之为线程），这类协程的上下文切换主要是操作系统提供（即跳板页代码以及用户态中断的上下文切换代码），而它的优先级则是由硬件来控制，其优先级凌驾于所有的软件协程之上，一旦硬件发出信号，其他软件协程只能无条件让权。

根据这种视角，可以把中断、异常、系统调用这几种需要硬件机制参与的过程也归结于硬件协程，从而使得跳板页代码和上下文切换的汇编代码归属于协程，并且也可以满足协程的主动切换的特性，从而能够解释这些处于特殊区域的代码。在内核中的其他代码附属于这些硬件协程或者属于软件协程。

共享调度器作为操作系统内核一个模块，它只能管理软件上的协程，对于硬件上的协程，只能配合其行为，充当硬件协程和软件协程的连接点。



##### 协程之间的边界？？？

1. 软件协程之间的边界在共享调度器
2. 硬件协程与软件协程之间的边界？硬件协程与硬件协程的边界？
    1. 





##### 同步与异步接口的统一

1. 通过 泛型/枚举 + trait 来实现函数重载
2. 同步系统调用与异步系统调用的区别
    1. 函数名 + 参数都相同
    2. 返回值不同，同步直接返回 i32，异步返回 dyn Future，但是需要明确指出返回的类型，这样还是不能做到极致的统一，（如果传递的参数不一致，那么可以明显的区分，但这也相当于明确指出返回类型）
3. 不做进一步的统一了，根据函数参数的不同进行区分还是使用不同的函数名进行区分，不能根据返回值进行区分，直接明确指出返回类型来做区分





网络包的头部也可以用 svd 的形式进行描述
